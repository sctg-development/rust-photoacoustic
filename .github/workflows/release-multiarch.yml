# Copyright 2025 SCTG Development - Ronan LE MEILLAT
# This workflow builds multi-architecture static binaries for rust-photoacoustic
# and creates GitHub releases with all photoacoustic tools

name: Generate multi-arch Docker image and release linux binaries

permissions:
  id-token: write
  contents: write
  attestations: write
  packages: write

on:
  release:
    types: [published]
  # Uncomment for manual testing:
  workflow_dispatch:

jobs:
  # Build non-static binaries for multiple platforms
  build_release_binaries:
    name: Build Release Binaries on ${{ matrix.os }} (${{ matrix.target }})
    runs-on: ${{ matrix.os }}
    
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            cross: false
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            cross: false
          - os: macos-13
            target: x86_64-apple-darwin
            cross: false
          - os: macos-latest
            target: aarch64-apple-darwin
            cross: true
    
    steps:
    # Set UTF-8 encoding for Windows to handle Unicode characters in Python scripts
    - name: Set UTF-8 encoding (Windows)
      if: runner.os == 'Windows'
      run: |
        echo "PYTHONIOENCODING=utf-8" >> $env:GITHUB_ENV
        echo "LANG=en_US.UTF-8" >> $env:GITHUB_ENV
        echo "LC_ALL=en_US.UTF-8" >> $env:GITHUB_ENV
      shell: pwsh

    - name: Clean runner for Docker builds
      if: matrix.os == 'ubuntu-latest'
      uses: sctg-development/clean-image-for-docker@v1
      with:
        remove-development-tools: 'false'
        remove-browsers: 'true'
        remove-databases: 'true'
        remove-cloud-tools: 'true'
        show-top-packages: 'true'

    - uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0
    
    # Debug submodules
    - name: Debug submodules
      shell: bash
      run: |
        echo "=== Git submodule status ==="
        git submodule status
        echo "=== .gitmodules content ==="
        cat .gitmodules || echo "No .gitmodules found"
        echo "=== Checking rust directory ==="
        ls -la rust/
        echo "=== Force submodule sync and update ==="
        git submodule sync --recursive
        git submodule update --init --recursive --force
        echo "=== Final submodule status ==="
        git submodule status
    
    # Install Rust toolchain
    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@v1
      with:
        toolchain: 1.86.0
        targets: ${{ matrix.target }}
        components: rustfmt, clippy
      
    # Install dependencies for Linux
    - name: Install Linux dependencies
      if: matrix.os == 'ubuntu-latest'
      run: |
        sudo apt-get update
        sudo apt-get install -y libssl-dev pkg-config gcc-aarch64-linux-gnu libasound2-dev
        
    # Install LLVM and Clang (required for bindgen)
    - name: Install LLVM and Clang
      uses: KyleMayes/install-llvm-action@v2
      with:
        version: "14.0"

    # Install Anaconda3 for Python support
    - name: Setup Anaconda3
      uses: conda-incubator/setup-miniconda@v3
      with:
        auto-update-conda: true
        python-version: '3.12'
        channels: conda-forge,defaults
        channel-priority: true
        activate-environment: release-env
        use-mamba: false
        conda-solver: classic
        auto-activate-base: true
        
    # Configure Python environment variables for PyO3
    - name: Configure Python environment
      shell: bash -l {0}
      run: |
        # Activate conda environment
        conda activate release-env
        
        # Set environment variables
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          echo "PYTHON_SYS_EXECUTABLE=$CONDA/envs/release-env/python.exe" >> $GITHUB_ENV
          echo "PYTHONPATH=$CONDA/envs/release-env/Lib/site-packages" >> $GITHUB_ENV
          echo "$CONDA/envs/release-env/Scripts" >> $GITHUB_PATH
          echo "$CONDA/envs/release-env" >> $GITHUB_PATH
        else
          echo "PYTHON_SYS_EXECUTABLE=$CONDA/envs/release-env/bin/python" >> $GITHUB_ENV
          echo "PYTHONPATH=$CONDA/envs/release-env/lib/python3.12/site-packages" >> $GITHUB_ENV
          echo "$CONDA/envs/release-env/bin" >> $GITHUB_PATH
          
          # Configure dynamic library path for macOS
          if [[ "${{ runner.os }}" == "macOS" ]]; then
            echo "DYLD_LIBRARY_PATH=$CONDA/envs/release-env/lib:$DYLD_LIBRARY_PATH" >> $GITHUB_ENV
          fi
        fi
        
        # Install required Python packages
        conda install -n release-env numpy scipy matplotlib -y

    # Set release tag
    - name: Set release tag
      id: set_tag
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # For manual workflow dispatch, use nightly tag with current date
          TAG="nightly.$(date +'%Y%m%d')"
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Using nightly tag: $TAG"
        else
          # For release events, use the release tag
          TAG="${{ github.event.release.tag_name }}"
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Using release tag: $TAG"
        fi

    # Cache Dependencies
    - name: Cache dependencies
      uses: Swatinem/rust-cache@v2
      with:
        workspaces: "rust -> target"
        key: rust-release-${{ matrix.os }}-${{ matrix.target }}
  
    - name: Create base configuration
      run: |
        cp rust/config.example.yaml rust/config.yaml

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '22'
        cache: 'npm'
        cache-dependency-path: 'web/package-lock.json'
    
    - name: Install Node.js dependencies
      run: |
        cd web
        npm install && npm run build
    
    # Build release binaries
    - name: Build release binaries
      shell: bash -l {0}
      run: |
        cd rust
        # Activate conda environment
        conda activate release-env
        
        # Configure macOS dynamic library path if needed
        if [[ "${{ runner.os }}" == "macOS" ]]; then
          export DYLD_LIBRARY_PATH="$CONDA/envs/release-env/lib:$DYLD_LIBRARY_PATH"
          echo "DYLD_LIBRARY_PATH set to: $DYLD_LIBRARY_PATH"
        fi
        
        # Build all binaries in release mode
        cargo build --release --target ${{ matrix.target }} --features python-driver

    # Package binaries with Python dependencies
    - name: Package binaries
      shell: bash -l {0}
      run: |
        cd rust
        conda activate release-env
        
        # Create package directory
        mkdir -p package/bin
        mkdir -p package/lib
        
        # Define file extensions based on OS
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          EXE_EXT=".exe"
          LIB_EXT=".dll"
          PYTHON_LIB_NAME="python312.dll"
        else
          EXE_EXT=""
          if [[ "${{ runner.os }}" == "macOS" ]]; then
            LIB_EXT=".dylib"
            PYTHON_LIB_NAME="libpython3.12.dylib"
          else
            LIB_EXT=".so"
            PYTHON_LIB_NAME="libpython3.12.so.1.0"
          fi
        fi
        
        # Copy all binaries
        for binary in rust_photoacoustic pid_tuner; do
          if [ -f "target/${{ matrix.target }}/release/${binary}${EXE_EXT}" ]; then
            cp "target/${{ matrix.target }}/release/${binary}${EXE_EXT}" "package/bin/"
          fi
        done
        
        # Copy Python library
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          cp "$CONDA/envs/release-env/${PYTHON_LIB_NAME}" package/lib/ || echo "Python library not found"
          cp "$CONDA/envs/release-env/Library/bin/python312.dll" package/lib/ || echo "Python312.dll not found"
        else
          cp "$CONDA/envs/release-env/lib/${PYTHON_LIB_NAME}" package/lib/ || echo "Python library not found"
        fi
        
        # Create launch scripts
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          # Windows batch script
          cat > package/rust_photoacoustic.bat << 'EOF'
        @echo off
        set SCRIPT_DIR=%~dp0
        set PATH=%SCRIPT_DIR%lib;%PATH%
        "%SCRIPT_DIR%bin\rust_photoacoustic.exe" %*
        EOF
          cat > package/pid_tuner.bat << 'EOF'
        @echo off
        set SCRIPT_DIR=%~dp0
        set PATH=%SCRIPT_DIR%lib;%PATH%
        "%SCRIPT_DIR%bin\pid_tuner.exe" %*
        EOF
        else
          # Unix shell script
          cat > package/rust_photoacoustic << 'EOF'
        #!/bin/bash
        SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        if [[ "$OSTYPE" == "darwin"* ]]; then
            export DYLD_LIBRARY_PATH="${SCRIPT_DIR}/lib:${DYLD_LIBRARY_PATH}"
        else
            export LD_LIBRARY_PATH="${SCRIPT_DIR}/lib:${LD_LIBRARY_PATH}"
        fi
        exec "${SCRIPT_DIR}/bin/rust_photoacoustic" "$@"
        EOF
          cat > package/pid_tuner << 'EOF'
        #!/bin/bash
        SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        if [[ "$OSTYPE" == "darwin"* ]]; then
            export DYLD_LIBRARY_PATH="${SCRIPT_DIR}/lib:${DYLD_LIBRARY_PATH}"
        else
            export LD_LIBRARY_PATH="${SCRIPT_DIR}/lib:${LD_LIBRARY_PATH}"
        fi
        exec "${SCRIPT_DIR}/bin/pid_tuner" "$@"
        EOF
          chmod +x package/rust_photoacoustic package/pid_tuner
        fi
        
        # Create README
        cat > package/README.md << 'EOF'
        # Rust Photoacoustic - Release Package
        
        This package contains the Rust Photoacoustic binaries with Python integration.
        
        ## Contents
        
        - `bin/`: Executable binaries
        - `lib/`: Required Python libraries
        - Launch scripts for easy execution
        
        ## Usage
        
        ### On Windows:
        ```
        rust_photoacoustic.bat [options]
        pid_tuner.bat [options]
        ```
        
        ### On macOS/Linux:
        ```
        ./rust_photoacoustic [options]
        ./pid_tuner [options]
        ```
        
        ## Requirements
        
        - No additional Python installation required
        - All dependencies are included in this package
        EOF
        
        # Add build info to README
        echo "" >> package/README.md
        echo "## Version" >> package/README.md
        echo "" >> package/README.md
        echo "Built from: ${{ github.sha }}" >> package/README.md
        echo "Target: ${{ matrix.target }}" >> package/README.md
        echo "Build Date: $(date)" >> package/README.md
        
        # Create archive
        ARCHIVE_NAME="rust-photoacoustic-${{ steps.set_tag.outputs.tag }}-${{ matrix.target }}"
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          7z a "${ARCHIVE_NAME}.zip" package/*
          echo "ARCHIVE_PATH=${ARCHIVE_NAME}.zip" >> $GITHUB_ENV
        else
          tar -czf "${ARCHIVE_NAME}.tar.gz" -C package .
          echo "ARCHIVE_PATH=${ARCHIVE_NAME}.tar.gz" >> $GITHUB_ENV
        fi

    # Upload artifacts
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: rust-photoacoustic-${{ matrix.target }}
        path: rust/${{ env.ARCHIVE_PATH }}
        retention-days: 90

  push_to_registry:
    permissions:
      id-token: write
      contents: write
      packages: write
      attestations: write
    name: Push Docker image to Docker Hub and release binaries
    runs-on: ubuntu-latest
    needs: build_release_binaries
    env:
      DOCKER_ARMHF_EXPERIMENTAL: off # Set to 'enabled' to enable armhf build
    steps:
      - name: Clean runner for Docker builds
        uses: sctg-development/clean-image-for-docker@v1
        # Optional parameters
        with:
            remove-development-tools: 'true'
            remove-browsers: 'true'
            remove-databases: 'true'
            remove-cloud-tools: 'true'
            show-top-packages: 'true'

      - name: Check out the repo
        uses: actions/checkout@v4
        with:
          submodules: recursive
          
      - name: Checkout submodules
        run: git submodule update --init --recursive
        
      - name: Set release tag
        id: set_tag
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # For manual workflow dispatch, use nightly tag with current date
            TAG="nightly.$(date +'%Y%m%d')"
            echo "tag=$TAG" >> $GITHUB_OUTPUT
            echo "Using nightly tag: $TAG"
          else
            # For release events, use the release tag
            TAG="${{ github.event.release.tag_name }}"
            echo "tag=$TAG" >> $GITHUB_OUTPUT
            echo "Using release tag: $TAG"
          fi

      - name: Create release for nightly builds
        if: github.event_name == 'workflow_dispatch'
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG=${{ steps.set_tag.outputs.tag }}
          echo "Creating nightly release: $TAG"
          gh release create "$TAG" --title "Nightly Build $TAG" --notes "Automated nightly build of rust-photoacoustic with multi-architecture static binaries." --prerelease

      # Download release artifacts from build job
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      # Upload non-static binaries to release
      - name: Upload release artifacts
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG=${{ steps.set_tag.outputs.tag }}
          echo "Uploading release artifacts for tag: $TAG"
          
          # Upload all downloaded artifacts
          for artifact_dir in artifacts/*/; do
            if [ -d "$artifact_dir" ]; then
              echo "Processing artifact directory: $artifact_dir"
              for file in "$artifact_dir"*; do
                if [ -f "$file" ]; then
                  echo "Uploading: $file"
                  gh release upload "$TAG" "$file" --clobber
                fi
              done
            fi
          done
        
      - name: Set Docker platforms
        id: set_platforms
        run: |
          if [ "${{ env.DOCKER_ARMHF_EXPERIMENTAL }}" = "enabled" ]; then
            echo "platforms=linux/arm64,linux/amd64,linux/arm/v7" >> $GITHUB_OUTPUT
            echo "Using platforms with armhf: linux/arm64,linux/amd64,linux/arm/v7"
          else
            echo "platforms=linux/arm64,linux/amd64" >> $GITHUB_OUTPUT
            echo "Using platforms without armhf: linux/arm64,linux/amd64"
          fi

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: ${{ steps.set_platforms.outputs.platforms }}
          
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
          
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./rust/docker/Dockerfile
          platforms: ${{ steps.set_platforms.outputs.platforms }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          push: true
          tags: sctg/rust-photoacoustic:${{ steps.set_tag.outputs.tag }}
          labels: |
            org.opencontainers.image.title=rust-photoacoustic
            org.opencontainers.image.description=Photoacoustic signal processing
            org.opencontainers.image.version=${{ steps.set_tag.outputs.tag }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}

      - name: Pull and extract files from Docker image (amd64)
        continue-on-error: true
        run: |
          export TAG=${{ steps.set_tag.outputs.tag }}
          mkdir -p /tmp/amd64/
          docker pull sctg/rust-photoacoustic:${TAG}
          docker create --platform linux/amd64 --name temp-container-amd64 sctg/rust-photoacoustic:${TAG}
          
          # Extract all photoacoustic binaries
          docker cp temp-container-amd64:/usr/local/bin/create_token /tmp/amd64/ || echo "create_token not found"
          docker cp temp-container-amd64:/usr/local/bin/analyze_spectrum /tmp/amd64/ || echo "analyze_spectrum not found"
          docker cp temp-container-amd64:/usr/local/bin/debug_config /tmp/amd64/ || echo "debug_config not found"
          docker cp temp-container-amd64:/usr/local/bin/differential /tmp/amd64/ || echo "differential not found"
          docker cp temp-container-amd64:/usr/local/bin/filters /tmp/amd64/ || echo "filters not found"
          docker cp temp-container-amd64:/usr/local/bin/modbus_client /tmp/amd64/ || echo "modbus_client not found"
          docker cp temp-container-amd64:/usr/local/bin/noise_generator /tmp/amd64/ || echo "noise_generator not found"
          docker cp temp-container-amd64:/usr/local/bin/pid_tuner /tmp/amd64/ || echo "pid_tuner not found"
          docker cp temp-container-amd64:/usr/local/bin/redis_viewer /tmp/amd64/ || echo "redis_viewer not found"
          docker cp temp-container-amd64:/usr/local/bin/rs256keygen /tmp/amd64/ || echo "rs256keygen not found"
          docker cp temp-container-amd64:/usr/local/bin/rust_photoacoustic /tmp/amd64/ || echo "rust_photoacoustic not found"
          # copy also the python binary and libpython static library
          docker cp temp-container-amd64:/usr/local/bin/python3.12 /tmp/amd64/ || echo "python3 not found"
          docker cp temp-container-amd64:/usr/local/lib/libpython3.12.a /tmp/amd64/ || echo "libpython3.12.a not found"
          
          docker rm temp-container-amd64
          
          # Rename binaries with architecture suffix
          cd /tmp/amd64/
          for binary in create_token analyze_spectrum debug_config differential filters modbus_client noise_generator pid_tuner redis_viewer rs256keygen rust_photoacoustic libpython3.12.a python3.12; do
            if [ -f "$binary" ]; then
              mv "$binary" "${binary}_linux_amd64_static_${{ steps.set_tag.outputs.tag }}"
            fi
          done

      - name: Pull and extract files from Docker image (arm64)
        continue-on-error: true
        run: |
          export TAG=${{ steps.set_tag.outputs.tag }}
          mkdir -p /tmp/arm64/
          docker pull sctg/rust-photoacoustic:${TAG}
          docker create --platform linux/arm64 --name temp-container-arm64 sctg/rust-photoacoustic:${TAG}
          
          # Extract all photoacoustic binaries
          docker cp temp-container-arm64:/usr/local/bin/create_token /tmp/arm64/ || echo "create_token not found"
          docker cp temp-container-arm64:/usr/local/bin/analyze_spectrum /tmp/arm64/ || echo "analyze_spectrum not found"
          docker cp temp-container-arm64:/usr/local/bin/debug_config /tmp/arm64/ || echo "debug_config not found"
          docker cp temp-container-arm64:/usr/local/bin/differential /tmp/arm64/ || echo "differential not found"
          docker cp temp-container-arm64:/usr/local/bin/filters /tmp/arm64/ || echo "filters not found"
          docker cp temp-container-arm64:/usr/local/bin/modbus_client /tmp/arm64/ || echo "modbus_client not found"
          docker cp temp-container-arm64:/usr/local/bin/noise_generator /tmp/arm64/ || echo "noise_generator not found"
          docker cp temp-container-arm64:/usr/local/bin/pid_tuner /tmp/arm64/ || echo "pid_tuner not found"
          docker cp temp-container-arm64:/usr/local/bin/redis_viewer /tmp/arm64/ || echo "redis_viewer not found"
          docker cp temp-container-arm64:/usr/local/bin/rs256keygen /tmp/arm64/ || echo "rs256keygen not found"
          docker cp temp-container-arm64:/usr/local/bin/rust_photoacoustic /tmp/arm64/ || echo "rust_photoacoustic not found"
          # copy also the python binary and libpython static library
          docker cp temp-container-arm64:/usr/local/bin/python3.12 /tmp/arm64/ || echo "python3 not found"
          docker cp temp-container-arm64:/usr/local/lib/libpython3.12.a /tmp/arm64/ || echo "libpython3.12.a not found"
          
          docker rm temp-container-arm64
          
          # Rename binaries with architecture suffix
          cd /tmp/arm64/
          for binary in create_token analyze_spectrum debug_config differential filters modbus_client noise_generator pid_tuner redis_viewer rs256keygen rust_photoacoustic libpython3.12.a python3.12; do
            if [ -f "$binary" ]; then
              mv "$binary" "${binary}_linux_arm64_static_${{ steps.set_tag.outputs.tag }}"
            fi
          done

      - name: Pull and extract files from Docker image (armhf)
        continue-on-error: true
        if: ${{ env.DOCKER_ARMHF_EXPERIMENTAL == 'enabled' }}
        run: |
          export TAG=${{ steps.set_tag.outputs.tag }}
          mkdir -p /tmp/armhf/
          docker pull sctg/rust-photoacoustic:latest
          docker create --platform linux/arm/v7 --name temp-container-armhf sctg/rust-photoacoustic:latest
          
          # Extract all photoacoustic binaries
          docker cp temp-container-armhf:/usr/local/bin/create_token /tmp/armhf/ || echo "create_token not found"
          docker cp temp-container-armhf:/usr/local/bin/analyze_spectrum /tmp/armhf/ || echo "analyze_spectrum not found"
          docker cp temp-container-armhf:/usr/local/bin/debug_config /tmp/armhf/ || echo "debug_config not found"
          docker cp temp-container-armhf:/usr/local/bin/differential /tmp/armhf/ || echo "differential not found"
          docker cp temp-container-armhf:/usr/local/bin/filters /tmp/armhf/ || echo "filters not found"
          docker cp temp-container-armhf:/usr/local/bin/modbus_client /tmp/armhf/ || echo "modbus_client not found"
          docker cp temp-container-armhf:/usr/local/bin/noise_generator /tmp/armhf/ || echo "noise_generator not found"
          docker cp temp-container-armhf:/usr/local/bin/pid_tuner /tmp/armhf/ || echo "pid_tuner not found"
          docker cp temp-container-armhf:/usr/local/bin/redis_viewer /tmp/armhf/ || echo "redis_viewer not found"
          docker cp temp-container-armhf:/usr/local/bin/rs256keygen /tmp/armhf/ || echo "rs256keygen not found"
          docker cp temp-container-armhf:/usr/local/bin/rust_photoacoustic /tmp/armhf/ || echo "rust_photoacoustic not found"
          # copy also the python binary and libpython static library
          docker cp temp-container-armhf:/usr/local/bin/python3.12 /tmp/armhf/ || echo "python3 not found"
          docker cp temp-container-armhf:/usr/local/lib/libpython3.12.a /tmp/armhf/ || echo "libpython3.12.a not found"
          
          docker rm temp-container-armhf
          
          # Rename binaries with architecture suffix
          cd /tmp/armhf/
          for binary in create_token analyze_spectrum debug_config differential filters modbus_client noise_generator pid_tuner redis_viewer rs256keygen rust_photoacoustic libpython3.12.a python3.12; do
            if [ -f "$binary" ]; then
              mv "$binary" "${binary}_linux_armhf_static_${{ steps.set_tag.outputs.tag }}"
            fi
          done

      - name: Upload amd64 Release binaries
        continue-on-error: true
        env:
            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
            echo "Uploading amd64 binaries..."
            ls -la /tmp/amd64/
            for binary in /tmp/amd64/*_linux_amd64_static_${{ steps.set_tag.outputs.tag }}; do
              if [ -f "$binary" ]; then
                echo "Uploading: $binary"
                gh release upload ${{ steps.set_tag.outputs.tag }} "$binary" --clobber
              fi
            done

      - name: Upload arm64 Release binaries
        continue-on-error: true
        env:
            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
            echo "Uploading arm64 binaries..."
            ls -la /tmp/arm64/
            for binary in /tmp/arm64/*_linux_arm64_static_${{ steps.set_tag.outputs.tag }}; do
              if [ -f "$binary" ]; then
                echo "Uploading: $binary"
                gh release upload ${{ steps.set_tag.outputs.tag }} "$binary" --clobber
              fi
            done

      - name: Upload armhf Release binaries
        continue-on-error: true
        env:
            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        if: ${{ env.DOCKER_ARMHF_EXPERIMENTAL == 'enabled' }}
        run: |
            echo "Uploading armhf binaries..."
            ls -la /tmp/armhf/
            for binary in /tmp/armhf/*_linux_armhf_static_${{ steps.set_tag.outputs.tag }}; do
              if [ -f "$binary" ]; then
                echo "Uploading: $binary"
                gh release upload ${{ steps.set_tag.outputs.tag }} "$binary" --clobber
              fi
            done

      - name: Create attestation for release binaries
        uses: actions/attest-build-provenance@v1
        continue-on-error: true
        with:
          subject-path: |
            /tmp/amd64/*_linux_amd64_static_${{ steps.set_tag.outputs.tag }}
            /tmp/arm64/*_linux_arm64_static_${{ steps.set_tag.outputs.tag }}
            /tmp/armhf/*_linux_armhf_static_${{ steps.set_tag.outputs.tag }}

      - name: Generate release summary
        run: |
          echo "## ðŸš€ Multi-Architecture Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“¦ Released Binaries" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Architecture | Static Binaries | Dynamic Binaries |" >> $GITHUB_STEP_SUMMARY
          echo "|--------------|-----------------|------------------|" >> $GITHUB_STEP_SUMMARY
          
          # AMD64 summary
          echo -n "| **Linux amd64** | " >> $GITHUB_STEP_SUMMARY
          ls /tmp/amd64/ 2>/dev/null | wc -l | tr -d '\n' >> $GITHUB_STEP_SUMMARY
          echo -n " static | " >> $GITHUB_STEP_SUMMARY
          ls artifacts/rust-photoacoustic-x86_64-unknown-linux-gnu/ 2>/dev/null | wc -l | tr -d '\n' >> $GITHUB_STEP_SUMMARY
          echo " dynamic |" >> $GITHUB_STEP_SUMMARY
          
          # ARM64 summary
          echo -n "| **Linux arm64** | " >> $GITHUB_STEP_SUMMARY
          ls /tmp/arm64/ 2>/dev/null | wc -l | tr -d '\n' >> $GITHUB_STEP_SUMMARY
          echo " static | N/A |" >> $GITHUB_STEP_SUMMARY
          
          # Windows summary
          echo -n "| **Windows x64** | N/A | " >> $GITHUB_STEP_SUMMARY
          ls artifacts/rust-photoacoustic-x86_64-pc-windows-msvc/ 2>/dev/null | wc -l | tr -d '\n' >> $GITHUB_STEP_SUMMARY
          echo " dynamic |" >> $GITHUB_STEP_SUMMARY
          
          # macOS Intel summary
          echo -n "| **macOS Intel** | N/A | " >> $GITHUB_STEP_SUMMARY
          ls artifacts/rust-photoacoustic-x86_64-apple-darwin/ 2>/dev/null | wc -l | tr -d '\n' >> $GITHUB_STEP_SUMMARY
          echo " dynamic |" >> $GITHUB_STEP_SUMMARY
          
          # macOS Apple Silicon summary
          echo -n "| **macOS Apple Silicon** | N/A | " >> $GITHUB_STEP_SUMMARY
          ls artifacts/rust-photoacoustic-aarch64-apple-darwin/ 2>/dev/null | wc -l | tr -d '\n' >> $GITHUB_STEP_SUMMARY
          echo " dynamic |" >> $GITHUB_STEP_SUMMARY
          
          # ARMHF summary
          if [ "${{ env.DOCKER_ARMHF_EXPERIMENTAL }}" = "enabled" ]; then
            echo -n "| **Linux armhf** | " >> $GITHUB_STEP_SUMMARY
            ls /tmp/armhf/ 2>/dev/null | wc -l | tr -d '\n' >> $GITHUB_STEP_SUMMARY
            echo " static | N/A |" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”§ Available Tools" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **rust_photoacoustic**: Main photoacoustic analysis server" >> $GITHUB_STEP_SUMMARY
          echo "- **pid_tuner**: PID controller tuning tool" >> $GITHUB_STEP_SUMMARY
          echo "- **Static binaries**: Self-contained Linux binaries (no dependencies)" >> $GITHUB_STEP_SUMMARY
          echo "- **Dynamic binaries**: Platform-specific binaries with Python integration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“‹ Package Contents" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Dynamic binary packages include:**" >> $GITHUB_STEP_SUMMARY
          echo "- \`bin/\`: Executable binaries" >> $GITHUB_STEP_SUMMARY
          echo "- \`lib/\`: Required Python libraries (.dylib/.dll/.so)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ³ Docker Image" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Multi-architecture Docker image available at: \`sctg/rust-photoacoustic:${{ steps.set_tag.outputs.tag }}\`" >> $GITHUB_STEP_SUMMARY
