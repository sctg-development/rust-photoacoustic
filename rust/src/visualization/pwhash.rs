// Copyright (c) 2025 Ronan LE MEILLAT, SCTG Development
// This file is part of the rust-photoacoustic project and is licensed under the
// SCTG Development Non-Commercial License v1.0 (see LICENSE.md for details).

//! Password hashing and verification utilities
//!
//! This module provides utilities for verifying password hashes
//! against the formats generated by `openssl passwd`.
//!
//! It supports verification of MD5, SHA-256, and SHA-512 crypt hashes.

/// Unix-style password hash verification
use std::fmt;

#[derive(Debug)]
pub enum Error {
    InvalidFormat,
    UnsupportedAlgorithm(String),
    InvalidHash,
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Error::InvalidFormat => write!(f, "Invalid hash format"),
            Error::UnsupportedAlgorithm(alg) => write!(f, "Unsupported algorithm: {}", alg),
            Error::InvalidHash => write!(f, "Invalid hash"),
        }
    }
}

impl std::error::Error for Error {}

/// Verify a password against a hash in OpenSSL passwd format
///
/// Supported formats:
/// - MD5 crypt ($1$)
/// - SHA-256 crypt ($5$)
/// - SHA-512 crypt ($6$)
///
/// ### Arguments
///
/// * `password` - The plaintext password to verify
/// * `hash` - The stored hash in OpenSSL passwd format
///
/// ### Returns
///
/// * `true` if the password matches the hash
/// * `false` otherwise
///
/// ### Example
///
/// ```
/// use rust_photoacoustic::visualization::pwhash;
///
/// let password = "admin123";
/// let hash = "$6$salt$hash"; // Example hash
///
/// if pwhash::verify(password, hash) {
///     println!("Password is correct!");
/// } else {
///     println!("Password is incorrect!");
/// }
/// ```
pub fn verify(password: &str, hash: &str) -> bool {
    match parse_hash(hash) {
        Ok((algorithm, salt, hash_value)) => match algorithm.as_str() {
            "$1$" => verify_md5crypt(password, salt.as_str(), hash_value.as_str()),
            "$5$" => verify_sha256crypt(password, salt.as_str(), hash_value.as_str()),
            "$6$" => verify_sha512crypt(password, salt.as_str(), hash_value.as_str()),
            _ => false,
        },
        Err(_) => false,
    }
}

fn parse_hash(hash: &str) -> Result<(String, String, String), Error> {
    let parts: Vec<&str> = hash.split('$').collect();

    if parts.len() < 4 {
        return Err(Error::InvalidFormat);
    }

    let algorithm = format!("${}$", parts[1]);

    match algorithm.as_str() {
        "$1$" | "$5$" | "$6$" => {
            let salt = parts[2].to_string();
            let hash_value = parts[3].to_string();

            Ok((algorithm, salt, hash_value))
        }
        _ => Err(Error::UnsupportedAlgorithm(algorithm)),
    }
}

fn verify_md5crypt(password: &str, salt: &str, hash_value: &str) -> bool {
    use pwhash::md5_crypt;
    md5_crypt::verify(password, &format!("$1${}${}", salt, hash_value))
}

fn verify_sha256crypt(password: &str, salt: &str, hash_value: &str) -> bool {
    use pwhash::sha256_crypt;
    sha256_crypt::verify(password, &format!("$5${}${}", salt, hash_value))
}

fn verify_sha512crypt(password: &str, salt: &str, hash_value: &str) -> bool {
    use pwhash::sha512_crypt;
    sha512_crypt::verify(password, &format!("$6${}${}", salt, hash_value))
}
