{
  "openapi": "3.0.0",
  "info": {
    "title": "rust_photoacoustic",
    "description": "Flexible Gas Analyzer using Laser Photoacoustic Spectroscopy",
    "version": "0.1.0"
  },
  "paths": {
    "/api/config": {
      "get": {
        "tags": [
          "Configuration"
        ],
        "description": "Get the current application configuration\n\n**Endpoint:** `GET /api/config`\n\nReturns the complete application configuration as JSON, including all sections: - Visualization server settings - Data acquisition configuration - Modbus TCP server settings - Photoacoustic measurement parameters - User access and permissions - Processing pipeline configuration - OAuth2/OIDC provider settings\n\nThis endpoint is useful for: - Administrative configuration review - Configuration validation and debugging - Dynamic configuration discovery by client applications - Configuration backup and documentation\n\n### Authentication\n\nThis endpoint requires a valid JWT bearer token in the Authorization header with administrative privileges. The token must have the `admin:api` scope.\n\n### Security Considerations\n\n**⚠️ WARNING:** This endpoint exposes sensitive configuration data including: - HMAC secrets and cryptographic keys - Database connection strings - Internal service URLs and credentials - User password hashes\n\nAccess should be restricted to trusted administrators only.\n\n### Returns\n\nReturns a JSON response containing the complete `Config` structure with all configuration sections populated according to the current application state.\n\n### Response Structure\n\n```json { \"visualization\": { \"enabled\": true, \"port\": 8080, \"address\": \"127.0.0.1\", \"hmac_secret\": \"...\", \"rs256_public_key_path\": null }, \"acquisition\": { \"enabled\": true, \"interval_ms\": 1000 }, \"modbus\": { \"enabled\": false, \"port\": 502, \"address\": \"127.0.0.1\" }, \"photoacoustic\": { \"input_device\": null, \"input_file\": null, \"frequency\": 1000.0, \"bandwidth\": 100.0, \"frame_size\": 1024, \"averages\": 10 }, \"access\": { \"users\": [...], \"clients\": [...], \"duration\": 86400, \"iss\": \"LaserSmartServer\" }, \"processing\": { \"enabled\": true, \"result_buffer_size\": 1000, \"default_graph\": {...}, \"performance\": {...} }, \"generix\": { \"provider\": \"generix\", \"api_base_url\": \"https://localhost:8080\", \"client_id\": \"LaserSmartClient\", \"scope\": \"openid email profile read:api write:api\", ... } } ```\n\n### Error Responses\n\n- `401 Unauthorized`: Missing or invalid JWT token - `403 Forbidden`: Token lacks required `admin:api` scope - `500 Internal Server Error`: Server error accessing configuration",
        "operationId": "get_config",
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Config"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/config.schema.json": {
      "get": {
        "tags": [
          "Configuration"
        ],
        "description": "Get the configuration schema\n\n**Endpoint:** `GET /api/config.schema.json`\n\nReturns the JSON schema for the application configuration, which defines the structure and validation rules for the configuration data.\n\nThis endpoint is useful for: - Client applications to validate configuration data - Documentation of configuration structure",
        "operationId": "get_config_schema",
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": true
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/config/visualization/output": {
      "get": {
        "tags": [
          "Configuration"
        ],
        "description": "Get the visualization.output configuration\n\n**Endpoint:** `GET /api/config/visualization/output`\n\nReturns the current visualization output configuration",
        "operationId": "get_visualization_output",
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/VisualizationOutputItem"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/graph-statistics": {
      "get": {
        "tags": [
          "Processing"
        ],
        "description": "Get processing graph statistics\n\n**Endpoint:** `GET /api/graph-statistics`\n\nReturns comprehensive statistics about the processing graph including: - Overall graph performance metrics - Individual node statistics - Execution timing information - Graph structure details\n\n### Authentication\n\nThis endpoint requires a valid JWT bearer token in the Authorization header. The token must have the appropriate scope for API access.\n\n### Returns\n\nReturns a JSON response containing `ProcessingGraphStatistics` with: - `node_statistics`: HashMap of node ID to performance statistics - `total_executions`: Total number of graph executions - `total_graph_processing_time`: Cumulative processing time - `average_graph_processing_time`: Average time per execution - `fastest_graph_execution`: Fastest recorded execution - `worst_graph_execution`: Slowest recorded execution - `active_nodes`: Number of active nodes in the graph - `connections_count`: Number of connections between nodes\n\n### Example Response\n\n```json { \"node_statistics\": { \"input\": { \"node_id\": \"input\", \"node_type\": \"input\", \"frames_processed\": 1000, \"total_processing_time\": \"PT1.234S\", \"average_processing_time\": \"PT0.001234S\", \"fastest_processing_time\": \"PT0.0008S\", \"worst_processing_time\": \"PT0.002S\" } }, \"total_executions\": 1000, \"total_graph_processing_time\": \"PT5.678S\", \"average_graph_processing_time\": \"PT0.005678S\", \"fastest_graph_execution\": \"PT0.003S\", \"worst_graph_execution\": \"PT0.012S\", \"active_nodes\": 4, \"connections_count\": 3 } ```\n\n### Error Responses\n\n- `401 Unauthorized`: Missing or invalid JWT token - `403 Forbidden`: Token lacks required scope - `404 Not Found`: No processing is currently active - `500 Internal Server Error`: Server error accessing statistics",
        "operationId": "get_graph_statistics",
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProcessingGraphStatistics"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/graph": {
      "get": {
        "tags": [
          "Processing"
        ],
        "description": "Get processing graph information\n\n**Endpoint:** `GET /api/graph`\n\nReturns a JSON object representing the current processing graph structure including nodes, connections, execution order, and topology information.\n\n### Authentication\n\nThis endpoint requires a valid JWT bearer token in the Authorization header. The token must have the appropriate scope for API access.\n\n### Returns\n\nReturns a JSON response containing `SerializableProcessingGraph` with: - `nodes`: Array of all processing nodes with their configurations - `connections`: Array of connections between nodes - `execution_order`: Topological order of node execution - `input_node`: ID of the designated input node - `output_node`: ID of the designated output node - `statistics`: Current performance statistics for the graph\n\n### Error Responses\n\n- `401 Unauthorized`: Missing or invalid JWT token - `403 Forbidden`: Token lacks required scope - `404 Not Found`: No processing graph is currently available - `500 Internal Server Error`: Server error accessing graph data",
        "operationId": "get_graph",
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SerializableProcessingGraph"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/graph/config": {
      "post": {
        "tags": [
          "Processing"
        ],
        "description": "Post new node configuration\n\n**Endpoint:** `POST /api/graph/config`\n\nThis endpoint allows updating the configuration of processing nodes that support hot-reloading. The configuration changes are applied to the shared configuration state and will be automatically detected by the background monitoring thread for hot-reload without requiring a restart.\n\n### Request Body\n\nThe request body must be a valid JSON object conforming to the `NodeConfig` schema:\n\n```json { \"id\": \"node_id\", \"node_type\": \"filter\", \"parameters\": { \"cutoff_frequency\": 1000.0, \"filter_type\": \"lowpass\" } } ```\n\n### Validation Process\n\nThe endpoint performs the following validation steps in order:\n\n1. **Processing graph availability**: Verifies that a processing graph is currently loaded 2. **Node existence**: Confirms the specified `node_id` exists in the active processing graph 3. **Hot-reload support**: Validates that the target node supports hot-reloading via `supports_hot_reload` flag 4. **Configuration presence**: Ensures the node exists in the shared configuration state 5. **Parameter merging**: Intelligently merges new parameters with existing configuration: - If both existing and new parameters are JSON objects: performs key-by-key merging - If existing parameters are not an object: replaces entirely with new parameters - If new parameters are not an object: replaces existing parameters entirely\n\n### Configuration Update Behavior\n\n- **Merge strategy**: New parameter values overwrite existing ones with the same key - **Preservation**: Existing parameters not specified in the request are preserved - **Atomic update**: Configuration changes are applied atomically within a write lock - **Hot-reload trigger**: Changes are automatically detected by the monitoring thread\n\n### Authentication\n\nThis endpoint requires a valid JWT bearer token in the Authorization header. The token must have the `admin:api` scope for API access.\n\n### Returns\n\nReturns a JSON response containing the complete updated node parameters after merging:\n\n```json { \"cutoff_frequency\": 1000.0, \"filter_type\": \"lowpass\", \"existing_param\": \"preserved_value\" } ```\n\n### Error Responses\n\n- `400 Bad Request`: - No processing graph is currently available - Node with the specified ID does not exist in the processing graph - Node does not support hot reloading - Node not found in configuration state - Invalid JSON structure in request body - `401 Unauthorized`: Missing or invalid JWT token - `403 Forbidden`: Token lacks required `admin:api` scope - `500 Internal Server Error`: Server error processing the request or configuration lock failure",
        "operationId": "post_node_config",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NodeConfig"
              }
            }
          },
          "required": true
        },
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": true
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/system/stats": {
      "get": {
        "tags": [
          "System"
        ],
        "description": "Get current system statistics\n\n**Endpoint:** `GET /api/system/stats`\n\nReturns current system resource usage including: - CPU usage percentage - Memory consumption (physical and virtual) - Thread count - System uptime information\n\n### Authentication\n\nThis endpoint requires a valid JWT bearer token in the Authorization header.\n\n### Returns\n\nReturns JSON response containing `SystemStats` with current system metrics.\n\n### Example Response\n\n```json { \"cpu_usage_percent\": 25.4, \"memory_usage_mb\": 512, \"virtual_memory_mb\": 1024, \"thread_count\": 8, \"total_cpu_cores\": 4, \"available_memory_mb\": 3584, \"uptime_seconds\": 86400, \"process_uptime_seconds\": 3600, \"timestamp\": 1640995200 } ```",
        "operationId": "get_system_stats",
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SystemStats"
                }
              }
            }
          },
          "default": {
            "description": ""
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/system/health": {
      "get": {
        "tags": [
          "System"
        ],
        "description": "Get comprehensive system health report\n\n**Endpoint:** `GET /api/system/health`\n\nReturns a comprehensive health assessment combining: - System resource statistics - Processing pipeline performance - Health status evaluation - Optimization recommendations\n\n### Authentication\n\nThis endpoint requires a valid JWT bearer token in the Authorization header.\n\n### Returns\n\nReturns JSON response containing `SystemHealthReport` with complete system assessment.\n\n### Health Status Levels\n\n- **Healthy**: All systems operating within normal parameters - **Warning**: Minor performance issues detected but system functional - **Critical**: Significant performance degradation requiring attention\n\n### Example Response\n\n```json { \"system_stats\": { /* SystemStats object */ }, \"processing_summary\": { \"avg_execution_time_ms\": 5.2, \"efficiency_percentage\": 98.5, \"active_nodes\": 4, \"total_executions\": 15420, \"slowest_node\": \"bandpass_filter\" }, \"health_status\": { \"Healthy\": null }, \"recommendations\": [ \"System operating optimally\" ] } ```",
        "operationId": "get_system_health",
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SystemHealthReport"
                }
              }
            }
          },
          "default": {
            "description": ""
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/action/{node_id}/history": {
      "get": {
        "tags": [
          "Action History"
        ],
        "description": "Get historical measurement data from a specific action node\n\nReturns measurement data stored in the action node's history buffer. The data is returned in chronological order (newest first).\n\n### Path Parameters - `node_id`: The ID of the action node to query\n\n### Query Parameters - `limit`: Maximum number of entries to return (optional)\n\n### Returns - `200 OK`: Array of measurement data - `404 Not Found`: Action node with the specified ID not found - `500 Internal Server Error`: Failed to access processing graph\n\n### Example Response ```json [ { \"concentration_ppm\": 456.78, \"source_node_id\": \"concentration_calculator\", \"peak_amplitude\": 0.85, \"peak_frequency\": 2000.5, \"timestamp\": 1640995200, \"metadata\": { \"trigger_type\": \"concentration_threshold\", \"alert_message\": \"High concentration detected\" } } ] ```",
        "operationId": "get_action_history",
        "parameters": [
          {
            "name": "node_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": true,
            "schema": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint",
              "minimum": 0
            }
          }
        ],
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MeasurementData"
                  }
                }
              }
            }
          },
          "default": {
            "description": ""
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/action/{node_id}/history/stats": {
      "get": {
        "tags": [
          "Action History"
        ],
        "description": "Get statistics about an action node's history buffer\n\nReturns metadata about the action node including buffer statistics, configuration, and performance metrics.\n\n### Path Parameters - `node_id`: The ID of the action node to query\n\n### Returns - `200 OK`: Statistics object - `404 Not Found`: Action node with the specified ID not found - `500 Internal Server Error`: Failed to access processing graph\n\n### Example Response ```json { \"node_id\": \"redis_stream_action\", \"node_type\": \"action_universal\", \"history_buffer\": { \"capacity\": 100, \"current_size\": 85, \"is_full\": false, \"oldest_entry_timestamp\": 1640995000, \"newest_entry_timestamp\": 1640995200 }, \"configuration\": { \"monitored_nodes\": [\"concentration_calculator\"], \"concentration_threshold\": 100.0, \"amplitude_threshold\": 0.65, \"update_interval_ms\": 5000 }, \"driver_info\": { \"has_driver\": true, \"driver_type\": \"configured\" }, \"performance\": { \"processing_count\": 1250, \"actions_triggered\": 15, \"last_update_time\": 1640995200, \"last_action_update\": 1640995195 } } ```",
        "operationId": "get_action_history_stats",
        "parameters": [
          {
            "name": "node_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": true
              }
            }
          },
          "default": {
            "description": ""
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/action": {
      "get": {
        "tags": [
          "Action History"
        ],
        "description": "List all available action nodes\n\nReturns a summary of all UniversalActionNode instances in the processing graph, including their basic configuration and status information.\n\n### Returns - `200 OK`: Array of action node information - `500 Internal Server Error`: Failed to access processing graph\n\n### Example Response ```json [ { \"id\": \"redis_stream_action\", \"node_type\": \"action_universal\", \"has_driver\": true, \"monitored_nodes_count\": 1, \"buffer_size\": 85, \"buffer_capacity\": 100 }, { \"id\": \"web_dashboard_action\", \"node_type\": \"action_universal\", \"has_driver\": true, \"monitored_nodes_count\": 1, \"buffer_size\": 200, \"buffer_capacity\": 300 } ] ```",
        "operationId": "list_action_nodes",
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ActionNodeInfo"
                  }
                }
              }
            }
          },
          "default": {
            "description": ""
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/test/{path}": {
      "get": {
        "tags": [
          "Test"
        ],
        "operationId": "test_api",
        "parameters": [
          {
            "name": "path",
            "in": "path",
            "required": true,
            "allow_reserved": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      },
      "post": {
        "tags": [
          "Test"
        ],
        "operationId": "test_post_api",
        "parameters": [
          {
            "name": "path",
            "in": "path",
            "required": true,
            "allow_reserved": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TestData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/test/web_dashboard_action": {
      "post": {
        "tags": [
          "Test"
        ],
        "description": "Test API endpoint for web dashboard display\n\nThis endpoint is used to test the API functionality for the web dashboard display. It returns a JSON response containing the request path, user information, and an optional message. It logs the concentration, amplitude, frequency, and timestamp from the display update data.",
        "operationId": "test_api_post_web_dashboard_display",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DisplayUpdateData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/": {
      "get": {
        "tags": [
          "webclient"
        ],
        "description": "Redirect the root path to the web client\n\nThis route handler redirects requests for the root path (`/`) to the web client's index.html file. This allows users to access the web interface by navigating to the server's root URL.\n\n### Returns\n\nA redirect response pointing to `/client/index.html`",
        "operationId": "webclient_index",
        "responses": {
          "500": {
            "description": ""
          }
        }
      }
    },
    "/index.html": {
      "get": {
        "tags": [
          "webclient"
        ],
        "description": "Redirect `/index.html` to the web client\n\nThis route handler redirects requests for `/index.html` to the web client's index.html file at `/client/index.html`. This provides a convenient shorthand URL for accessing the web interface.\n\n### Returns\n\nA redirect response pointing to `/client/index.html`",
        "operationId": "webclient_index_html",
        "responses": {
          "500": {
            "description": ""
          }
        }
      }
    },
    "/{_path}": {
      "options": {
        "tags": [
          "Cors"
        ],
        "description": "Handler for HTTP OPTIONS requests required for CORS preflight\n\nThis handler responds to OPTIONS requests with a 200 OK response, which is necessary for CORS preflight requests. The CORS fairing will add the appropriate headers to the response.\n\n### Parameters\n\n* `_path` - The path requested (ignored in this implementation)\n\n### Returns\n\nAn empty success result to indicate that the preflight request is accepted",
        "operationId": "options",
        "parameters": [
          {
            "name": "_path",
            "in": "path",
            "required": true,
            "allow_reserved": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          },
          "500": {
            "description": ""
          }
        }
      }
    },
    "/api/computing": {
      "get": {
        "tags": [
          "Computing"
        ],
        "description": "Computing API endpoint that returns live data from SharedComputingState",
        "operationId": "computing_api",
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ComputingResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/thermal/regulators": {
      "get": {
        "tags": [
          "Thermal Regulation"
        ],
        "description": "Get the list of available thermal regulators\n\n**Endpoint:** `GET /api/thermal/regulators`\n\nReturns a list of all thermal regulator identifiers that are currently configured in the system. This list can be used to filter thermal data requests to specific regulators.\n\n### Authentication\n\nThis endpoint requires a valid JWT bearer token in the Authorization header with read access privileges. The token must have the `read:api` scope.\n\n### Returns\n\nReturns a JSON array containing the string identifiers of all available thermal regulators in the system.\n\n### Response Structure\n\n```json [ \"regulator_1\", \"regulator_2\", \"main_chamber_heater\", \"coolant_system\" ] ```\n\n### Error Responses\n\n- `401 Unauthorized`: Missing or invalid JWT token - `403 Forbidden`: Token lacks required `read:api` scope - `500 Internal Server Error`: Server error accessing thermal regulation state",
        "operationId": "get_thermal_regulators",
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/thermal": {
      "get": {
        "tags": [
          "Thermal Regulation"
        ],
        "description": "Get thermal regulation data with filtering and pagination\n\n**Endpoint:** `GET /api/thermal`\n\nReturns historical thermal regulation data with optional filtering by time range, regulators, and data sampling. The response includes pagination support for efficient handling of large datasets.\n\nThis endpoint provides access to: - Historical temperature measurements from all thermal regulators - PID controller output values and setpoints - Individual PID component values (P, I, D terms) for control analysis - Configurable data sampling intervals to reduce response size - Time-range filtering for specific analysis periods - Regulator-specific data filtering\n\n### Query Parameters\n\nAll query parameters are optional and can be combined to customize the response:\n\n- `steps` - Time interval in seconds between returned data points - Default: 60 seconds (1 minute intervals) - Set to 0 to return all available data points - Higher values reduce response size by sampling data\n\n- `regulators` - Array of regulator IDs to include in response - Default: All regulators included - Use `/api/thermal/regulators` to get available regulator IDs - Example: `?regulators=main_heater&regulators=coolant_pump`\n\n- `from` - Start timestamp for data range (Unix seconds or ISO 8601) - Default: Beginning of available data - Example: `?from=1672531200` or `?from=2023-01-01T00:00:00Z`\n\n- `to` - End timestamp for data range (Unix seconds or ISO 8601) - Default: Most recent data - Example: `?to=1672617600` or `?to=2023-01-02T00:00:00Z`\n\n- `page` - Page number for pagination (1-indexed) - Default: 1 - Used with `limit` parameter for result pagination\n\n- `limit` - Maximum number of data points per regulator per page - Default: 1000 - Maximum: 10000 to prevent excessive response sizes\n\n### Authentication\n\nThis endpoint requires a valid JWT bearer token in the Authorization header with read access privileges. The token must have the `read:api` scope.\n\n### Response Structure\n\nReturns a JSON response with the following structure:\n\n```json { \"data\": { \"regulator_1\": [ { \"timestamp\": 1672531260, \"temperature_celsius\": 23.5, \"control_output_percent\": 15.2, \"setpoint_celsius\": 25.0, \"pid_components\": { \"proportional\": 1.5, \"integral\": 0.3, \"derivative\": -0.1, \"error\": 1.5 } } ] }, \"pagination\": { \"page\": 1, \"limit\": 1000, \"total_items\": 2500, \"total_pages\": 3, \"has_next\": true, \"has_previous\": false }, \"filters\": { \"step_seconds\": 60, \"included_regulators\": [\"regulator_1\", \"regulator_2\"], \"from_timestamp\": 1672531200, \"to_timestamp\": 1672617600 } } ```\n\n### Data Sampling and Performance\n\nFor optimal performance with large datasets: - Use the `steps` parameter to reduce data density - Apply time range filtering with `from` and `to` parameters - Use pagination for datasets exceeding 1000 points per regulator - Consider filtering to specific regulators when only subset analysis is needed\n\n### Error Responses\n\n- `400 Bad Request`: Invalid query parameters (e.g., invalid timestamp format) - `401 Unauthorized`: Missing or invalid JWT token - `403 Forbidden`: Token lacks required `read:api` scope - `422 Unprocessable Entity`: Invalid parameter values (e.g., page < 1, limit > 10000) - `500 Internal Server Error`: Server error accessing thermal regulation data\n\n### Examples\n\nGet last hour of data with 5-minute intervals: ```text GET /api/thermal?steps=300&from=1672531200&to=1672534800 ```\n\nGet specific regulator data with pagination: ```text GET /api/thermal?regulators=main_heater&page=2&limit=500 ```\n\nGet all available data for analysis: ```text GET /api/thermal?steps=0 ```",
        "operationId": "get_thermal_data",
        "parameters": [
          {
            "name": "steps",
            "in": "query",
            "required": true,
            "schema": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0
            }
          },
          {
            "name": "regulators",
            "in": "query",
            "required": true,
            "schema": {
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "from",
            "in": "query",
            "required": true,
            "schema": {
              "type": [
                "string",
                "null"
              ]
            }
          },
          {
            "name": "to",
            "in": "query",
            "required": true,
            "schema": {
              "type": [
                "string",
                "null"
              ]
            }
          },
          {
            "name": "page",
            "in": "query",
            "required": true,
            "schema": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": true,
            "schema": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0
            }
          }
        ],
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedThermalResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/thermal/temperatures": {
      "get": {
        "tags": [
          "Thermal Regulation"
        ],
        "description": "Get the last recorded temperatures for all thermal regulators\n\n**Endpoint:** `GET /api/thermal/temperatures`\n\nReturns the most recent temperature reading for each thermal regulator in the system. This provides a quick snapshot of the current thermal state without historical data.\n\n### Authentication\n\nThis endpoint requires a valid JWT bearer token in the Authorization header with read access privileges. The token must have the `read:api` scope.\n\n### Returns\n\nReturns a JSON object containing the regulator ID as the key and current temperature information as the value. Each regulator entry includes: - Current temperature in degrees Celsius - Timestamp of the last reading (Unix seconds) - Current setpoint temperature - Regulator status\n\n### Response Structure\n\n```json { \"regulator_1\": { \"temperature_celsius\": 23.5, \"timestamp\": 1672531260, \"setpoint_celsius\": 25.0, \"status\": \"Running\" }, \"main_chamber_heater\": { \"temperature_celsius\": 45.2, \"timestamp\": 1672531265, \"setpoint_celsius\": 50.0, \"status\": \"Running\" } } ```\n\n### Error Responses\n\n- `401 Unauthorized`: Missing or invalid JWT token - `403 Forbidden`: Token lacks required `read:api` scope - `500 Internal Server Error`: Server error accessing thermal regulation state\n\n### Notes\n\n- If a regulator has no temperature readings, it will not appear in the response - The timestamp indicates when the temperature reading was taken - Status values include: \"Uninitialized\", \"Initializing\", \"Running\", \"Error\", \"Stopped\"",
        "operationId": "get_last_temperatures",
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/CurrentTemperatureInfo"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/stream/stats": {
      "get": {
        "tags": [
          "Audio Streaming"
        ],
        "description": "Get realtime source stream statistics\n\nReturns information about the audio stream including frame rates, subscriber count, and other metrics.",
        "operationId": "get_stream_stats",
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StreamStats"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/stream/audio/fast/stats": {
      "get": {
        "tags": [
          "Audio Streaming"
        ],
        "description": "Get realtime source stream statistics\n\nReturns information about the audio stream including frame rates, subscriber count, and other metrics.",
        "operationId": "get_stream_fast_stats",
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StreamStats"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/stream/latest": {
      "get": {
        "tags": [
          "Audio Streaming"
        ],
        "description": "Get the latest audio frame from realtime source\n\nReturns the most recent audio frame without subscribing to the stream. Useful for getting current state or testing connectivity.",
        "operationId": "get_latest_frame",
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AudioFrameResponse"
                }
              }
            }
          },
          "404": {
            "description": ""
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/stream/audio": {
      "get": {
        "tags": [
          "Audio Streaming"
        ],
        "description": "Stream audio frames via Server-Sent Events\n\nProvides a continuous stream of audio frames to web clients using Server-Sent Events. Each event contains a complete audio frame with both channels of data. Source is the realtime source\n\n### Authentication Requires a valid JWT token with appropriate read permissions. The token is transmitted via \"Authorization: Bearer <token>\" .\n\n### Response Format The stream sends JSON-encoded audio frames as SSE events: ```json data: {\"channel_a\": [...], \"channel_b\": [...], ...}\n\n```",
        "operationId": "stream_audio",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "text/event-stream": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "integer",
                    "format": "uint8",
                    "minimum": 0,
                    "maximum": 255
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/stream/audio/fast": {
      "get": {
        "tags": [
          "Audio Streaming"
        ],
        "description": "Stream realtime source frames via Server-Sent Events using fast binary format\n\nSimilar to stream_audio but uses base64-encoded binary data for reduced bandwidth. This can reduce data size by approximately 1.9x compared to JSON arrays.",
        "operationId": "stream_audio_fast",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "text/event-stream": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "integer",
                    "format": "uint8",
                    "minimum": 0,
                    "maximum": 255
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/stream/audio/{node_id}": {
      "get": {
        "tags": [
          "Audio Streaming"
        ],
        "description": "Stream audio frames via Server-Sent Events for a specific streaming node (JSON format)\n\n**DEPRECATED:** Use [`/api/stream/audio/fast/<node_id>`] for more efficient binary streaming with node routing.\n\nThis endpoint streams real-time audio frames from a specific `StreamingNode` identified by its UUID or string ID. Each event contains a JSON-encoded audio frame with both channels of data. The endpoint is primarily intended for backward compatibility and debugging, as the fast binary endpoint is recommended for production use.\n\n### Route Pattern `/api/stream/audio/<node_id>` where `node_id` can be: - A UUID string: `123e4567-e89b-12d3-a456-426614174000` - A string ID from node configuration: `my_streaming_node`\n\n### Parameters - `node_id`: The UUID or string ID of the streaming node to subscribe to (as a path parameter) - `stream_state`: Rocket-managed state containing the streaming registry\n\n### Authentication Requires a valid JWT token with `read:api` permission.\n\n### Response Format Streams Server-Sent Events (SSE) with JSON-encoded audio frames:\n\n```json data:{\"channel_a\": [...], \"channel_b\": [...], \"sample_rate\": 44100, ...} ```\n\nIf the node ID is invalid or not found, an error event is sent:\n\n```json data:{\"type\": \"error\", \"message\": \"No streaming node found\"} ```\n\nHeartbeat events are sent every 5 seconds if no frame is available:\n\n```json data:{\"type\": \"heartbeat\"} ```\n\n### Deprecation This endpoint is deprecated in favor of [`/stream/audio/fast/<node_id>`], which uses a more efficient binary format for audio data. New clients should use the fast endpoint for lower bandwidth and better performance.\n\n### Examples\n\n```text GET /api/stream/audio/123e4567-e89b-12d3-a456-426614174000 GET /api/stream/audio/my_streaming_node ```\n\n### See Also - [`/stream/audio/fast/<node_id>`]: Fast binary streaming for a specific node - [`/stream/nodes`]: List all available streaming nodes and their UUIDs",
        "operationId": "stream_audio_with_node_id",
        "parameters": [
          {
            "name": "node_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "text/event-stream": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "integer",
                    "format": "uint8",
                    "minimum": 0,
                    "maximum": 255
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/stream/audio/fast/{node_id}": {
      "get": {
        "tags": [
          "Audio Streaming"
        ],
        "description": "Stream audio frames via Server-Sent Events using fast binary format with dynamic node ID routing\n\nThis endpoint supports routing to specific streaming nodes using their UUID. When a node_id is provided, it queries the StreamingNodeRegistry for the appropriate stream. If no matching node is found, returns a 404 error.\n\n### Route Pattern `/api/stream/audio/fast/<node_id>` where `node_id` is a UUID string\n\n### Examples - `/stream/audio/fast/123e4567-e89b-12d3-a456-426614174000` - Stream from specific node\n\n### Authentication Requires a valid JWT token with `read:api` permission.",
        "operationId": "stream_audio_fast_with_node_id",
        "parameters": [
          {
            "name": "node_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "text/event-stream": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "integer",
                    "format": "uint8",
                    "minimum": 0,
                    "maximum": 255
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/stream/spectral": {
      "get": {
        "tags": [
          "Audio Streaming"
        ],
        "description": "Stream spectral analysis data via Server-Sent Events\n\nProvides real-time spectral analysis data computed from the audio frames. The analysis includes FFT magnitude and optionally phase information for both audio channels.\n\n### Authentication Requires a valid JWT token with appropriate read permissions.\n\n### Response Format The stream sends JSON-encoded spectral data as SSE events: ```json data: {\"frequencies\": [...], \"magnitude_a\": [...], \"magnitude_b\": [...], ...}\n\n```",
        "operationId": "stream_spectral_analysis",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "text/event-stream": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "integer",
                    "format": "uint8",
                    "minimum": 0,
                    "maximum": 255
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/stream/nodes": {
      "get": {
        "tags": [
          "Audio Streaming"
        ],
        "description": "List all available streaming nodes\n\nReturns information about all registered streaming nodes in the system. This endpoint is useful for discovering available streams and their status.\n\n### Authentication Requires a valid JWT token with `read:api` permission.\n\n### Response Format Returns a JSON array of streaming node information: ```json [ { \"id\": \"my_streaming_node\", \"uuid\": \"123e4567-e89b-12d3-a456-426614174000\", \"name\": \"Recording Node 1\", \"is_active\": true, \"subscriber_count\": 2 } ] ```",
        "operationId": "list_streaming_nodes",
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/StreamingNodeInfo"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/stream/nodes/{node_id}/stats": {
      "get": {
        "tags": [
          "Audio Streaming"
        ],
        "description": "Get statistics for a specific streaming node\n\nReturns detailed statistics for a specific streaming node identified by its UUID or string ID. The endpoint supports both formats: - UUID format: `123e4567-e89b-12d3-a456-426614174000` - String ID format: `my_streaming_node`\n\n### Authentication Requires a valid JWT token with `read:api` permission.",
        "operationId": "get_node_stats",
        "parameters": [
          {
            "name": "node_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StreamStats"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/stream/audio/fast/{node_id}/stats": {
      "get": {
        "tags": [
          "Audio Streaming"
        ],
        "description": "Get statistics for a specific fast streaming node\n\nReturns detailed statistics for a specific streaming node identified by its UUID or string ID. The endpoint supports both formats: - UUID format: `123e4567-e89b-12d3-a456-426614174000` - String ID format: `my_streaming_node`\n\n### Authentication Requires a valid JWT token with `read:api` permission.",
        "operationId": "get_node_fast_stats",
        "parameters": [
          {
            "name": "node_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StreamStats"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    },
    "/api/stream/audio/get-all-streams": {
      "get": {
        "tags": [
          "Audio Streaming"
        ],
        "description": "Retrieve all available audio streams\n\nThis endpoint lists all currently active audio streams in the system. Includes streams from nodes (by id) as well as the realtime source stream.\n\n### Authentication Requires a valid JWT token with `read:api` permission.\n\n### Response Format Returns a JSON array of audio stream information objects: ```json [ { \"id\": \"realtime_source\", \"stream_url\": \"/api/stream/audio/fast\", \"stats_url\": \"/api/stream/audio/fast/stats\" }, { \"id\": \"streaming_output\", \"stream_url\": \"/api/stream/audio/fast/streaming_output\", \"stats_url\": \"/api/stream/audio/fast/streaming_output/stats\" } ] ```",
        "operationId": "get_all_available_fast_audio_streams",
        "responses": {
          "403": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/AudioStreamInfo"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid or missing Bearer token",
            "content": {
              "application/json": {
                "example": {
                  "error": "Invalid or missing Bearer token"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - Authentication service unavailable",
            "content": {
              "application/json": {
                "example": {
                  "error": "Authentication service unavailable"
                }
              }
            }
          }
        },
        "security": [
          {
            "BearerAuth": []
          }
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "Config": {
        "description": "Root configuration structure for the photoacoustic application.\n\nThis structure serves as the main container for all configuration sections\nof the application. Currently, it only contains visualization settings, but\nit can be expanded to include other sections as the application grows.\n\n### Structure\n\nThe configuration is designed to be deserialized from and serialized to YAML\nusing the serde framework. The structure is validated against a JSON schema\nto ensure all required fields are present and have valid values.\n\n### Default Values\n\nEach section uses default values when not explicitly specified in the configuration\nfile, allowing for minimal configuration when custom settings are not required.",
        "type": "object",
        "properties": {
          "visualization": {
            "description": "Settings for the visualization web server component.\n\nThese settings control how the visualization server behaves, including\nnetwork binding, security, and authentication mechanisms.\nIf not specified in the configuration file, default values are used.",
            "default": {
              "port": 8080,
              "address": "127.0.0.1",
              "name": "LaserSmartApiServer/0.1.0",
              "cert": "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUJvekNDQVVtZ0F3SUJBZ0lVVmsvWDVLNVpaZVlxQkhhSXBIc1BqNzZWRjFJd0NnWUlLb1pJemowRUF3SXcKSXpFaE1COEdBMVVFQXd3WWNuVnpkQzF3YUc5MGIyRmpiM1Z6ZEdsakxteHZZMkZzTUI0WERUSTFNRFV5T0RBMQpNalF3T0ZvWERUSTJNRFV5T0RBMU1qUXdPRm93SXpFaE1COEdBMVVFQXd3WWNuVnpkQzF3YUc5MGIyRmpiM1Z6CmRHbGpMbXh2WTJGc01Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRXZuTUpBSzN5OUtodlBQR20KRmN6U1NsTHJxZFJxWURERW1OUllITFNXVnpFU2VkVC9wRWtIN2hHanpHcHBuNGhaRERsOWd4VmtEYzRYeWlKYQpGcHBCYktOYk1Ga3dSZ1lEVlIwUkJEOHdQWUlZY25WemRDMXdhRzkwYjJGamIzVnpkR2xqTG14dlkyRnNnZ2xzCmIyTmhiR2h2YzNTSEJIOEFBQUdIRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUV3RHdZRFZSMFBBUUgvQkFVREF3ZWcKQURBS0JnZ3Foa2pPUFFRREFnTklBREJGQWlCK1NmdmlNNk1Vc0s3SWkxdWZuZmUwTldQelo4OExvc2Y4bHlBVQpHbTNHVXdJaEFNQWFNQmszdWpJSU8yWjNLejlSNmlrenNnT1Q4aGxSRzgxOERPV09KSUMvCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K",
              "key": "LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JR0hBZ0VBTUJNR0J5cUdTTTQ5QWdFR0NDcUdTTTQ5QXdFSEJHMHdhd0lCQVFRZ2c0cUNhWFowVTJWeWpjL0gKek1TSE94dnJpbU1TcEpjYlYzdnpPWWszTUQ2aFJBTkNBQVMrY3drQXJmTDBxRzg4OGFZVnpOSktVdXVwMUdwZwpNTVNZMUZnY3RKWlhNUko1MVAra1NRZnVFYVBNYW1tZmlGa01PWDJERldRTnpoZktJbG9XbWtGcwotLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tCg==",
              "hmac_secret": "my-super-secret-jwt-key-for-photoacoustic-app",
              "rs256_private_key": "LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlKS0FJQkFBS0NBZ0VBdjBxWi9WOFhJNVlaald6MUZzTkpHS0E5Q095TXl4RzkxSVFzT2FycmVBNTZTTGQrCmYwNUZyN3hhQkJyaThDa1JNN0NpNDY1b0dmM3VScXVLYmhMRjg1d1ovV2RWYjBpMFg4RzJvRnpnMTFsZkpKcjIKN0lWSkIxTlZIRjJKYmp1SGFHQmlGenNUTG1QMTNWRno2ZW44K2lqREpYTXd2d3hsZnhPRWdzTmtGSHBkTHo4UgpDM3FGaGFEV2M1aDAyQXlzRTFKc0p1Y3ZxMDYxMmV1cjcrb3RkUVR1eE9uMXVJa3Z5N2FxRmJpWlJnNHZMdzVHClFFVDJuT3I5LzJTdEJxSDI4UUk4emNVS3VwZi9Kd3hmbDFrMTNnZWNwOWkvRWZZR3JYdHJxYm9xYmluRkRVYUcKQzVaZWFsQU4zTTBCeXpmU09adjdJUWx6ZXllUW1CNTNwN25jSEFNV01Ic1JMT2tvUUtLM3gxekpCSUUyU3FzTQovdUdudkg3YkZqR21GN3JCWnpUWHd6NGNmaVVxbjdlNzU2eXJDeFNnZlhDdy9OTVlNcnBXSk9wZ3JtV0xndi9ICkZjV0JOWU1KeEhoOWFGOHovQm1LVTlrNFZSaC8yNWRkOEF0MHgxNnExTU4xbXloRGJNYWJtVVhwMTNDTzQrVnUKb1c5SElKWDFJZHBIUkRGeVlHVHFZYy9PMUJNc1NKOWJYNm9haXl4UE0yaVFGZElPRkIrcGpEUnNDUUdOT1YxSgpmREx6dEI4emtOaWorMXhPRGZRKzkxbCticnA0b0F4ckVERFBZcFBrd1N3ODI2MmRNblgvZWZIVlBuUXA0aEtOCnRKa3g2WHByK281bUFJdG1jRG1ZcWlndTRGVGc4T25yd1FPcytQMGg4OSszNXlJRk1mVEl6OUJWWlFrQ0F3RUEKQVFLQ0FnQk9SdmJRcWRMTUt5WDFxM3AzZ0I0dlI1THlUZW9uUnZGSlAzVGhmRUd5OVNteEMvVmxudUFCVTYvNgpNZzVmZkU2ZnVrNU5vUmJVWEFiZlFGNzdRQTlrNnFId0FoTUI0TngrdXNSQ3h2N3k0STJBYXpGVUJBNm9RcjkzClJnZHc1a2M0dlFnbXZYUFI3ZkcwU1JxSHc4cFRpODZmU28zT0FBS2doNW9YOEdESnlIRE5YcDlZOVNBaVdIaXAKQU4vL2NPQVJZQThGdEdEYlZ2QXZack1MRCtiZUZkQ25INTMvajVQUlpzUWU4MVUxUjZTak90SWdocGZzQ25VNQp4emJPbWdSMUJ4ZGVsSjBaVWcyRkt4a0swK1NwSUxCSU52ZXBIK1lIbzVPZzlwOWFTUmxybjBwRy81ZFBKY2NtCmJYV29kUVUvc2NhSDlGZ2ZNMGVHR0NHYXJ3R1VkMGRPRnV5cThxZzQxZkZHLzIwTzR4Vmh2MEVyNEhnSXFNSXUKdW9hQjJMbXlURVYyKys1U0o2YlFqVnhFQ3YwTW04Y2h3SVlrV2RMUzkwUVkrQzBvWldiZFdKNnNSVUtpdmhSTAorODk4ejViSWNQWk5acVdXTWlhMTBGRUIzUVdQRVBKNEwwZ3I3VTNSSlpRSlg3dnVwd25FS1E5bHV4UW5uWGw0CklaTUplT2Q0OXd4Qk1MNVJ1Sjg1UGZwZXBCa05CWVRWTHRFNDFDME9YVUpLWHhmVC9JeERwb1dNdVp2SURuZFAKYy8rblMxd2pDNmN4MkJvSVJXaGtJU25JbzdqNjlmWS9xSVFQTFpWc2hET3BYZzh2MXhWQlJ5RkVNaFA1SW5xeQpNZlRHQk9oNndEQksrM0VKTkhZNTh5WlFxZ2tPd3BjZy93cUtEUmJPM1pIVXU5WFppUUtDQVFFQTdwVFMvRVlsCnJMZEo1TmVzTExOb1BGTXFyL2xDcHhuYzF0bnA5Mlp6eUtiSlZHeFhoVy83THhaQkVFU2x0WUFQNDg3T3lNTk0KT1FCcU12dUNjK0o2dTFEVU42emhNZVU3Q1VaeEsweHk4a3hYUGROV1loVWZXSnRpWEZ6VkVNZExYK0lyQlQrbwpaMlM1Q3Azc3dxVlFKVDlWS2h1N0hNSlYrL1VqeWYvcHFlNXNGSm45VHp6RjN4U3Fpc3Exd245UmdMUFZ1aHJOCjIybTFjZnNkWWRLQUtmaWNndnVCL3dja3FBaXY3c3RvaGVocmhmb21ITFZvV0lGRnJzMGwxMW80RkhYVzhaeWkKK3ZJQ2tMUy8xQkptRmpZUnBBZVFLaDBxZFRjOXNIUzVMUGUvN3laVG56bHlUeCs1YWlsU0o2REx6VU9mL0dRSQovbk5Cak5Ba2NwVXVLd0tDQVFFQXpVSHBIRUQ2VEdRR1I5NXF5eGJLaHQyS3o4UzVJNm9GNkl1aFhmN1cvQ3R0Ck96MnFTbDV4NmFSQytEYzYzdHFTTGI5dlk3Y0tpd1MwQmY5NFA2UTFOTDhKdlQweEh5UThTLzJKQmtCdm85RDcKWFc5OUJ0bWZaOEc2SWQ4eVo0WlRsNnliU3dJZk9RM3BWSlJIWXU3Y1ROQ2sxUHk3UkIvc2IzM1pNQWs5RFdwUQp4UWRkWHh1SHNaeGgxYTVPbjRBSEw4Syt6ZGRJTGVBVldDbmlFTll0clFYWDZqSk5PS3hORk5uODdYR1psaFVvCng5MFk0RVN0a3RxSGJSNi9iNlZUNWdvVGt3RDdISlZkUjdVcXgxMjN0N3JoSWgwdXpwTnRRL3NodmJUZmZvVkwKNGFSLzdhRDdNT05qRFpiQXpDOWZ1ZGhNZGJCTWtaRm5xd2lnaTEvVG13S0NBUUVBNWRrWEV0ZjV2OVd0S1B6bQo4UUcrc0M5bmRyVnJFMVdGUHJBZUNhejRheHpUNWJPaTlma1dReHpyZmVMRXlvRWZ6ZGNWdkxENkpBaFVSOTJxCnBqNVJBMWt4dXBtaE10S205NTZYdEtFb05HcDd1aUo2bkcvQkRUcFZucW9JMHV0Tm9JaGg3ZUtRT1Z2K01VNUkKSkpYakNwOWpTdmdBWWdxUGovZHhqVkF4S3ZkNXhMYytKVEpsWnkrZnhhclpSUkluMFJod0ZhVnhJYXRMbFEzYQpGcjRYbjFmV1lSSXhBU00rbTJ3VElybHdiMkdsQlNRang1QzFnRjY2WlZkYTE0Z2hjd1M4R1hWUVJ2Y1VwWmlkCkhwRERMUzdWKy9NVlhwMU9wREtlQ2Z2SjBwcTBuSStPREYzcDFIUzV5cDhZZVBrZW54aEJiNFJvYmN0WUlYTDkKU2k2U2xRS0NBUUJ1YUNtdjNQUEY2M2ZGYU1vZys5MXN0ZlpZMUFTU1BuNTNHOFJzL3dzOUVVN3NNcnRLellxUQpscDYvVFZZSlVhQ1hvd1dUcVgydVVaVlVOSnJHQU5udHlXUy91ZzZXSmJPWlhJTThMYVRmaFNYd21HdTBKNU1yCkNIWEtpbmhlWDA3UG96VFZJQXNUY1h3MDFwMmZoY1JTUFZpc2lGVml5NWt1VDQ5bjIxQlB5d1F2TjBydVFheTMKeU5xSFNmOVlwRkU1UzVPK3ZUSkNHdXJnUlljb2IweWFhUzQrOTFlNlNGUWVCek9adFNWY0tYMktKRStoTXMvNgowamxPWk4rc2VrMnF5M2pEOWg4Y3ZPczBDeXM3bWhtY1pwVjYrQitaVm92THFXWDQyVFh1cEZ5d3Z2OWhIdHArCjdaRDJXa1RTa0JqNXFuTldTc0trK29XODVpTVZWVEpKQW9JQkFCVEpmRG1wNUhCSDJ2YlFaK3FMN0ZnT0hJckMKZ1JjUllkVGVYdEhOQVhEZDJBNXpJMUdqRG4vQnYvZ1lKbEo4M0pBRXd1OHVCdUZuVDk4K1JFRXhkQ0k5Yk5rRQppZFZacjh4VDRsSUhxemFLNUIraTFBaUlNZStFeFJQd254ZExhT0NLVUsxYWViOU5yWE1zRGM4YlloT1Baa2dOCm9iMkpQVUs5azBwaWdHV1Z1SzBaTHJuQWN3RzZaZ1c1NTZPOTY2cXFUdWtRMlJoZlhLU0cyMzdZZmhmWmdoUk4KOFl3RnB4dnNNcGJVQndtdjI1Y1Z2S2ptYWhOZThheWxOc2FvZjZ2ZVc1TnhZdlgzTHUrNWtycHZ4RnY0ZVUvSwpNcnY4ZUtadStHVFBOU2ZsTTdjWHQ3WGxKclBPL3JaSG1JTHExQ0poNmRHNGt4dHcrRHgxTGFpTi9Zbz0KLS0tLS1FTkQgUlNBIFBSSVZBVEUgS0VZLS0tLS0K",
              "rs256_public_key": "LS0tLS1CRUdJTiBSU0EgUFVCTElDIEtFWS0tLS0tCk1JSUNDZ0tDQWdFQXYwcVovVjhYSTVZWmpXejFGc05KR0tBOUNPeU15eEc5MUlRc09hcnJlQTU2U0xkK2YwNUYKcjd4YUJCcmk4Q2tSTTdDaTQ2NW9HZjN1UnF1S2JoTEY4NXdaL1dkVmIwaTBYOEcyb0Z6ZzExbGZKSnIyN0lWSgpCMU5WSEYySmJqdUhhR0JpRnpzVExtUDEzVkZ6NmVuOCtpakRKWE13dnd4bGZ4T0Vnc05rRkhwZEx6OFJDM3FGCmhhRFdjNWgwMkF5c0UxSnNKdWN2cTA2MTJldXI3K290ZFFUdXhPbjF1SWt2eTdhcUZiaVpSZzR2THc1R1FFVDIKbk9yOS8yU3RCcUgyOFFJOHpjVUt1cGYvSnd4ZmwxazEzZ2VjcDlpL0VmWUdyWHRycWJvcWJpbkZEVWFHQzVaZQphbEFOM00wQnl6ZlNPWnY3SVFsemV5ZVFtQjUzcDduY0hBTVdNSHNSTE9rb1FLSzN4MXpKQklFMlNxc00vdUduCnZIN2JGakdtRjdyQlp6VFh3ejRjZmlVcW43ZTc1NnlyQ3hTZ2ZYQ3cvTk1ZTXJwV0pPcGdybVdMZ3YvSEZjV0IKTllNSnhIaDlhRjh6L0JtS1U5azRWUmgvMjVkZDhBdDB4MTZxMU1OMW15aERiTWFibVVYcDEzQ080K1Z1b1c5SApJSlgxSWRwSFJERnlZR1RxWWMvTzFCTXNTSjliWDZvYWl5eFBNMmlRRmRJT0ZCK3BqRFJzQ1FHTk9WMUpmREx6CnRCOHprTmlqKzF4T0RmUSs5MWwrYnJwNG9BeHJFRERQWXBQa3dTdzgyNjJkTW5YL2VmSFZQblFwNGhLTnRKa3gKNlhwcitvNW1BSXRtY0RtWXFpZ3U0RlRnOE9ucndRT3MrUDBoODkrMzV5SUZNZlRJejlCVlpRa0NBd0VBQVE9PQotLS0tLUVORCBSU0EgUFVCTElDIEtFWS0tLS0tCg==",
              "enabled": true,
              "session_secret": "r11Eq5kJzR4wpSZPCyJjVvaq8rWmiB7h9lDrbZaaG6Y=",
              "enable_compression": true,
              "output": []
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/VisualizationConfig"
              }
            ]
          },
          "acquisition": {
            "description": "Acquisition settings for the photoacoustic application.\n\nThis section controls parameters related to the data acquisition process,\nsuch as enabling/disabling acquisition, and the interval between acquisitions.\nIf not specified, default values will be used.",
            "default": {
              "enabled": true,
              "interval_ms": 1000
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/AcquisitionConfig"
              }
            ]
          },
          "modbus": {
            "description": "Modbus settings for the photoacoustic application.\n\nThis section controls parameters related to the Modbus communication,\nsuch as enabling/disabling Modbus, the port to use, and the address.\nIf not specified, default values will be used.",
            "default": {
              "enabled": false,
              "port": 502,
              "address": "127.0.0.1"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ModbusConfig"
              }
            ]
          },
          "photoacoustic": {
            "description": "Photoacoustic settings for the photoacoustic application.\n\nThis section controls parameters related to the photoacoustic\nacquisition, such as the input device, input file, frequency,\nbandwidth, window size, and number of spectra to average.\nIf not specified, default values will be used.",
            "default": {
              "input_device": "first",
              "frequency": 1000.0,
              "bandwidth": 50.0,
              "frame_size": 4096,
              "averages": 10,
              "sample_rate": 44100,
              "precision": 16,
              "record_consumer": false,
              "record_file": "recorded_audio.wav"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/PhotoacousticConfig"
              }
            ]
          },
          "access": {
            "description": "User access and permissions settings for the photoacoustic application.\n\nThis section controls parameters related to user authentication and\nauthorization, such as the list of users, their credentials, and\nassociated permissions. If not specified, default values will be used.",
            "default": {
              "users": [
                {
                  "user": "admin",
                  "pass": "JDUkM2E2OUZwQW0xejZBbWV2QSRvMlhhN0lxcVdVU1VPTUh6UVJiM3JjRlRhZy9WYjdpSWJtZUJFaXA3Y1ZECg==",
                  "permissions": [
                    "read:api",
                    "write:api",
                    "admin:api",
                    "openid",
                    "profile",
                    "email"
                  ],
                  "email": "email@example.org",
                  "name": "Admin User"
                }
              ],
              "clients": [
                {
                  "client_id": "LaserSmartClient",
                  "allowed_callbacks": [
                    "http://localhost:8080/client/",
                    "https://localhost:8080/client/"
                  ],
                  "default_scope": "openid profile email read:api write:api"
                }
              ],
              "duration": 86400,
              "iss": "LaserSmartServer"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/AccessConfig"
              }
            ]
          },
          "processing": {
            "description": "Processing settings for the photoacoustic application.\n\nThis section controls parameters related to the audio processing pipeline,\nsuch as processing graphs, nodes configuration, and performance settings.\nIf not specified, default values will be used.",
            "default": {
              "enabled": true,
              "result_buffer_size": 1000,
              "default_graph": {
                "id": "default",
                "nodes": [
                  {
                    "id": "input",
                    "node_type": "input",
                    "parameters": null
                  },
                  {
                    "id": "channel_selector",
                    "node_type": "channel_selector",
                    "parameters": {
                      "target_channel": "ChannelA"
                    }
                  }
                ],
                "connections": [
                  {
                    "from": "input",
                    "to": "channel_selector"
                  }
                ],
                "output_node": "channel_selector"
              },
              "performance": {
                "max_processing_time_us": 10000,
                "enable_stats": true,
                "stats_interval_ms": 1000
              }
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ProcessingConfig"
              }
            ]
          },
          "thermal_regulation": {
            "description": "Thermal regulation settings for the photoacoustic application.\n\nThis section controls parameters related to thermal regulation system,\nincluding I2C controllers, PID regulators, and thermal actuators.\nIf not specified, default values will be used.",
            "default": {
              "enabled": false,
              "i2c_buses": {},
              "regulators": [],
              "global_settings": {
                "global_sampling_rate_hz": 10.0,
                "max_concurrent_regulators": 32,
                "resource_sharing": {
                  "i2c_arbitration_timeout_ms": 100,
                  "max_operation_queue_size": 100,
                  "priority_scheduling": false
                },
                "monitoring": {
                  "enable_performance_monitoring": true,
                  "metrics_interval_s": 1.0,
                  "enable_thermal_history": false,
                  "history_buffer_size": 1000
                }
              }
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ThermalRegulationConfig"
              }
            ]
          },
          "generix": {
            "default": {
              "provider": "generix",
              "api_base_url": "https://localhost:8080",
              "authority": "https://localhost:8080",
              "client_id": "LaserSmartClient",
              "scope": "openid email profile read:api write:api",
              "redirect_uri": "https://localhost:8080/client/",
              "audience": "LaserSmartClient",
              "token_issuer": "https://localhost:8080",
              "jwks_endpoint": "https://localhost:8080/.well-known/jwks.json",
              "domain": "localhost",
              "issuer": "LaserSmartServer"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/GenerixConfig"
              }
            ]
          }
        }
      },
      "VisualizationConfig": {
        "description": "Configuration for the visualization web server.\n\nThis structure contains all settings required for the visualization server component,\nincluding network binding parameters, TLS certificate settings, and authentication\nconfiguration with both HMAC and RSA key-based JWT options.\n\n### Security Options\n\nThe structure supports two JWT authentication mechanisms:\n\n1. **HMAC-based JWT**: A simple secret key used for both signing and verification\n2. **RS256-based JWT**: More secure public/private key pair where:\n   - Private key is used for signing tokens\n   - Public key is used for verifying tokens\n\nThe RS256 keys can be generated using the included `rs256keygen` binary.\n\n### TLS Configuration\n\nFor secure HTTPS connections, both `cert` and `key` fields must be provided as\nBase64-encoded PEM files. If either is missing, the server will operate in non-TLS mode.",
        "type": "object",
        "properties": {
          "port": {
            "description": "The TCP port the visualization server will listen on.\n\nValid range is 1-65534. Default value is 8080.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0,
            "maximum": 65535,
            "default": 8080
          },
          "address": {
            "description": "The network address the server will bind to.\n\nCan be an IPv4/IPv6 address or a hostname. Default is \"127.0.0.1\".\nUse \"0.0.0.0\" to bind to all IPv4 interfaces.",
            "type": "string",
            "default": "127.0.0.1"
          },
          "name": {
            "description": "The server name reported in HTTP headers and logs.\n\nDefault is \"LaserSmartApiServer/\" followed by the package version.",
            "type": "string",
            "default": "LaserSmartApiServer/0.1.0"
          },
          "cert": {
            "description": "SSL/TLS certificate in PEM format, Base64 encoded.\n\nIf provided, `key` must also be supplied. For development,\ndefaults to the certificate in the resources directory.",
            "type": "string",
            "default": "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUJvekNDQVVtZ0F3SUJBZ0lVVmsvWDVLNVpaZVlxQkhhSXBIc1BqNzZWRjFJd0NnWUlLb1pJemowRUF3SXcKSXpFaE1COEdBMVVFQXd3WWNuVnpkQzF3YUc5MGIyRmpiM1Z6ZEdsakxteHZZMkZzTUI0WERUSTFNRFV5T0RBMQpNalF3T0ZvWERUSTJNRFV5T0RBMU1qUXdPRm93SXpFaE1COEdBMVVFQXd3WWNuVnpkQzF3YUc5MGIyRmpiM1Z6CmRHbGpMbXh2WTJGc01Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRXZuTUpBSzN5OUtodlBQR20KRmN6U1NsTHJxZFJxWURERW1OUllITFNXVnpFU2VkVC9wRWtIN2hHanpHcHBuNGhaRERsOWd4VmtEYzRYeWlKYQpGcHBCYktOYk1Ga3dSZ1lEVlIwUkJEOHdQWUlZY25WemRDMXdhRzkwYjJGamIzVnpkR2xqTG14dlkyRnNnZ2xzCmIyTmhiR2h2YzNTSEJIOEFBQUdIRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUV3RHdZRFZSMFBBUUgvQkFVREF3ZWcKQURBS0JnZ3Foa2pPUFFRREFnTklBREJGQWlCK1NmdmlNNk1Vc0s3SWkxdWZuZmUwTldQelo4OExvc2Y4bHlBVQpHbTNHVXdJaEFNQWFNQmszdWpJSU8yWjNLejlSNmlrenNnT1Q4aGxSRzgxOERPV09KSUMvCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K",
            "nullable": true
          },
          "key": {
            "description": "SSL/TLS private key in PEM format, Base64 encoded.\n\nIf provided, `cert` must also be supplied. For development,\ndefaults to the key in the resources directory.",
            "type": "string",
            "default": "LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JR0hBZ0VBTUJNR0J5cUdTTTQ5QWdFR0NDcUdTTTQ5QXdFSEJHMHdhd0lCQVFRZ2c0cUNhWFowVTJWeWpjL0gKek1TSE94dnJpbU1TcEpjYlYzdnpPWWszTUQ2aFJBTkNBQVMrY3drQXJmTDBxRzg4OGFZVnpOSktVdXVwMUdwZwpNTVNZMUZnY3RKWlhNUko1MVAra1NRZnVFYVBNYW1tZmlGa01PWDJERldRTnpoZktJbG9XbWtGcwotLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tCg==",
            "nullable": true
          },
          "hmac_secret": {
            "description": "Secret key for HMAC-based JWT token signing and verification.\n\nUsed when RS256 keys are not available or for simpler deployments.\nNot recommended for production environments.",
            "type": "string",
            "default": "my-super-secret-jwt-key-for-photoacoustic-app"
          },
          "rs256_private_key": {
            "description": "RS256 private key in PEM format, Base64 encoded.\n\nUsed for signing JWT tokens with the RS256 algorithm.\nCan be generated with the `rs256keygen` binary.",
            "type": "string",
            "default": "LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlKS0FJQkFBS0NBZ0VBdjBxWi9WOFhJNVlaald6MUZzTkpHS0E5Q095TXl4RzkxSVFzT2FycmVBNTZTTGQrCmYwNUZyN3hhQkJyaThDa1JNN0NpNDY1b0dmM3VScXVLYmhMRjg1d1ovV2RWYjBpMFg4RzJvRnpnMTFsZkpKcjIKN0lWSkIxTlZIRjJKYmp1SGFHQmlGenNUTG1QMTNWRno2ZW44K2lqREpYTXd2d3hsZnhPRWdzTmtGSHBkTHo4UgpDM3FGaGFEV2M1aDAyQXlzRTFKc0p1Y3ZxMDYxMmV1cjcrb3RkUVR1eE9uMXVJa3Z5N2FxRmJpWlJnNHZMdzVHClFFVDJuT3I5LzJTdEJxSDI4UUk4emNVS3VwZi9Kd3hmbDFrMTNnZWNwOWkvRWZZR3JYdHJxYm9xYmluRkRVYUcKQzVaZWFsQU4zTTBCeXpmU09adjdJUWx6ZXllUW1CNTNwN25jSEFNV01Ic1JMT2tvUUtLM3gxekpCSUUyU3FzTQovdUdudkg3YkZqR21GN3JCWnpUWHd6NGNmaVVxbjdlNzU2eXJDeFNnZlhDdy9OTVlNcnBXSk9wZ3JtV0xndi9ICkZjV0JOWU1KeEhoOWFGOHovQm1LVTlrNFZSaC8yNWRkOEF0MHgxNnExTU4xbXloRGJNYWJtVVhwMTNDTzQrVnUKb1c5SElKWDFJZHBIUkRGeVlHVHFZYy9PMUJNc1NKOWJYNm9haXl4UE0yaVFGZElPRkIrcGpEUnNDUUdOT1YxSgpmREx6dEI4emtOaWorMXhPRGZRKzkxbCticnA0b0F4ckVERFBZcFBrd1N3ODI2MmRNblgvZWZIVlBuUXA0aEtOCnRKa3g2WHByK281bUFJdG1jRG1ZcWlndTRGVGc4T25yd1FPcytQMGg4OSszNXlJRk1mVEl6OUJWWlFrQ0F3RUEKQVFLQ0FnQk9SdmJRcWRMTUt5WDFxM3AzZ0I0dlI1THlUZW9uUnZGSlAzVGhmRUd5OVNteEMvVmxudUFCVTYvNgpNZzVmZkU2ZnVrNU5vUmJVWEFiZlFGNzdRQTlrNnFId0FoTUI0TngrdXNSQ3h2N3k0STJBYXpGVUJBNm9RcjkzClJnZHc1a2M0dlFnbXZYUFI3ZkcwU1JxSHc4cFRpODZmU28zT0FBS2doNW9YOEdESnlIRE5YcDlZOVNBaVdIaXAKQU4vL2NPQVJZQThGdEdEYlZ2QXZack1MRCtiZUZkQ25INTMvajVQUlpzUWU4MVUxUjZTak90SWdocGZzQ25VNQp4emJPbWdSMUJ4ZGVsSjBaVWcyRkt4a0swK1NwSUxCSU52ZXBIK1lIbzVPZzlwOWFTUmxybjBwRy81ZFBKY2NtCmJYV29kUVUvc2NhSDlGZ2ZNMGVHR0NHYXJ3R1VkMGRPRnV5cThxZzQxZkZHLzIwTzR4Vmh2MEVyNEhnSXFNSXUKdW9hQjJMbXlURVYyKys1U0o2YlFqVnhFQ3YwTW04Y2h3SVlrV2RMUzkwUVkrQzBvWldiZFdKNnNSVUtpdmhSTAorODk4ejViSWNQWk5acVdXTWlhMTBGRUIzUVdQRVBKNEwwZ3I3VTNSSlpRSlg3dnVwd25FS1E5bHV4UW5uWGw0CklaTUplT2Q0OXd4Qk1MNVJ1Sjg1UGZwZXBCa05CWVRWTHRFNDFDME9YVUpLWHhmVC9JeERwb1dNdVp2SURuZFAKYy8rblMxd2pDNmN4MkJvSVJXaGtJU25JbzdqNjlmWS9xSVFQTFpWc2hET3BYZzh2MXhWQlJ5RkVNaFA1SW5xeQpNZlRHQk9oNndEQksrM0VKTkhZNTh5WlFxZ2tPd3BjZy93cUtEUmJPM1pIVXU5WFppUUtDQVFFQTdwVFMvRVlsCnJMZEo1TmVzTExOb1BGTXFyL2xDcHhuYzF0bnA5Mlp6eUtiSlZHeFhoVy83THhaQkVFU2x0WUFQNDg3T3lNTk0KT1FCcU12dUNjK0o2dTFEVU42emhNZVU3Q1VaeEsweHk4a3hYUGROV1loVWZXSnRpWEZ6VkVNZExYK0lyQlQrbwpaMlM1Q3Azc3dxVlFKVDlWS2h1N0hNSlYrL1VqeWYvcHFlNXNGSm45VHp6RjN4U3Fpc3Exd245UmdMUFZ1aHJOCjIybTFjZnNkWWRLQUtmaWNndnVCL3dja3FBaXY3c3RvaGVocmhmb21ITFZvV0lGRnJzMGwxMW80RkhYVzhaeWkKK3ZJQ2tMUy8xQkptRmpZUnBBZVFLaDBxZFRjOXNIUzVMUGUvN3laVG56bHlUeCs1YWlsU0o2REx6VU9mL0dRSQovbk5Cak5Ba2NwVXVLd0tDQVFFQXpVSHBIRUQ2VEdRR1I5NXF5eGJLaHQyS3o4UzVJNm9GNkl1aFhmN1cvQ3R0Ck96MnFTbDV4NmFSQytEYzYzdHFTTGI5dlk3Y0tpd1MwQmY5NFA2UTFOTDhKdlQweEh5UThTLzJKQmtCdm85RDcKWFc5OUJ0bWZaOEc2SWQ4eVo0WlRsNnliU3dJZk9RM3BWSlJIWXU3Y1ROQ2sxUHk3UkIvc2IzM1pNQWs5RFdwUQp4UWRkWHh1SHNaeGgxYTVPbjRBSEw4Syt6ZGRJTGVBVldDbmlFTll0clFYWDZqSk5PS3hORk5uODdYR1psaFVvCng5MFk0RVN0a3RxSGJSNi9iNlZUNWdvVGt3RDdISlZkUjdVcXgxMjN0N3JoSWgwdXpwTnRRL3NodmJUZmZvVkwKNGFSLzdhRDdNT05qRFpiQXpDOWZ1ZGhNZGJCTWtaRm5xd2lnaTEvVG13S0NBUUVBNWRrWEV0ZjV2OVd0S1B6bQo4UUcrc0M5bmRyVnJFMVdGUHJBZUNhejRheHpUNWJPaTlma1dReHpyZmVMRXlvRWZ6ZGNWdkxENkpBaFVSOTJxCnBqNVJBMWt4dXBtaE10S205NTZYdEtFb05HcDd1aUo2bkcvQkRUcFZucW9JMHV0Tm9JaGg3ZUtRT1Z2K01VNUkKSkpYakNwOWpTdmdBWWdxUGovZHhqVkF4S3ZkNXhMYytKVEpsWnkrZnhhclpSUkluMFJod0ZhVnhJYXRMbFEzYQpGcjRYbjFmV1lSSXhBU00rbTJ3VElybHdiMkdsQlNRang1QzFnRjY2WlZkYTE0Z2hjd1M4R1hWUVJ2Y1VwWmlkCkhwRERMUzdWKy9NVlhwMU9wREtlQ2Z2SjBwcTBuSStPREYzcDFIUzV5cDhZZVBrZW54aEJiNFJvYmN0WUlYTDkKU2k2U2xRS0NBUUJ1YUNtdjNQUEY2M2ZGYU1vZys5MXN0ZlpZMUFTU1BuNTNHOFJzL3dzOUVVN3NNcnRLellxUQpscDYvVFZZSlVhQ1hvd1dUcVgydVVaVlVOSnJHQU5udHlXUy91ZzZXSmJPWlhJTThMYVRmaFNYd21HdTBKNU1yCkNIWEtpbmhlWDA3UG96VFZJQXNUY1h3MDFwMmZoY1JTUFZpc2lGVml5NWt1VDQ5bjIxQlB5d1F2TjBydVFheTMKeU5xSFNmOVlwRkU1UzVPK3ZUSkNHdXJnUlljb2IweWFhUzQrOTFlNlNGUWVCek9adFNWY0tYMktKRStoTXMvNgowamxPWk4rc2VrMnF5M2pEOWg4Y3ZPczBDeXM3bWhtY1pwVjYrQitaVm92THFXWDQyVFh1cEZ5d3Z2OWhIdHArCjdaRDJXa1RTa0JqNXFuTldTc0trK29XODVpTVZWVEpKQW9JQkFCVEpmRG1wNUhCSDJ2YlFaK3FMN0ZnT0hJckMKZ1JjUllkVGVYdEhOQVhEZDJBNXpJMUdqRG4vQnYvZ1lKbEo4M0pBRXd1OHVCdUZuVDk4K1JFRXhkQ0k5Yk5rRQppZFZacjh4VDRsSUhxemFLNUIraTFBaUlNZStFeFJQd254ZExhT0NLVUsxYWViOU5yWE1zRGM4YlloT1Baa2dOCm9iMkpQVUs5azBwaWdHV1Z1SzBaTHJuQWN3RzZaZ1c1NTZPOTY2cXFUdWtRMlJoZlhLU0cyMzdZZmhmWmdoUk4KOFl3RnB4dnNNcGJVQndtdjI1Y1Z2S2ptYWhOZThheWxOc2FvZjZ2ZVc1TnhZdlgzTHUrNWtycHZ4RnY0ZVUvSwpNcnY4ZUtadStHVFBOU2ZsTTdjWHQ3WGxKclBPL3JaSG1JTHExQ0poNmRHNGt4dHcrRHgxTGFpTi9Zbz0KLS0tLS1FTkQgUlNBIFBSSVZBVEUgS0VZLS0tLS0K"
          },
          "rs256_public_key": {
            "description": "RS256 public key in PEM format, Base64 encoded.\n\nUsed for verifying JWT tokens signed with the RS256 algorithm.\nCan be generated with the `rs256keygen` binary.",
            "type": "string",
            "default": "LS0tLS1CRUdJTiBSU0EgUFVCTElDIEtFWS0tLS0tCk1JSUNDZ0tDQWdFQXYwcVovVjhYSTVZWmpXejFGc05KR0tBOUNPeU15eEc5MUlRc09hcnJlQTU2U0xkK2YwNUYKcjd4YUJCcmk4Q2tSTTdDaTQ2NW9HZjN1UnF1S2JoTEY4NXdaL1dkVmIwaTBYOEcyb0Z6ZzExbGZKSnIyN0lWSgpCMU5WSEYySmJqdUhhR0JpRnpzVExtUDEzVkZ6NmVuOCtpakRKWE13dnd4bGZ4T0Vnc05rRkhwZEx6OFJDM3FGCmhhRFdjNWgwMkF5c0UxSnNKdWN2cTA2MTJldXI3K290ZFFUdXhPbjF1SWt2eTdhcUZiaVpSZzR2THc1R1FFVDIKbk9yOS8yU3RCcUgyOFFJOHpjVUt1cGYvSnd4ZmwxazEzZ2VjcDlpL0VmWUdyWHRycWJvcWJpbkZEVWFHQzVaZQphbEFOM00wQnl6ZlNPWnY3SVFsemV5ZVFtQjUzcDduY0hBTVdNSHNSTE9rb1FLSzN4MXpKQklFMlNxc00vdUduCnZIN2JGakdtRjdyQlp6VFh3ejRjZmlVcW43ZTc1NnlyQ3hTZ2ZYQ3cvTk1ZTXJwV0pPcGdybVdMZ3YvSEZjV0IKTllNSnhIaDlhRjh6L0JtS1U5azRWUmgvMjVkZDhBdDB4MTZxMU1OMW15aERiTWFibVVYcDEzQ080K1Z1b1c5SApJSlgxSWRwSFJERnlZR1RxWWMvTzFCTXNTSjliWDZvYWl5eFBNMmlRRmRJT0ZCK3BqRFJzQ1FHTk9WMUpmREx6CnRCOHprTmlqKzF4T0RmUSs5MWwrYnJwNG9BeHJFRERQWXBQa3dTdzgyNjJkTW5YL2VmSFZQblFwNGhLTnRKa3gKNlhwcitvNW1BSXRtY0RtWXFpZ3U0RlRnOE9ucndRT3MrUDBoODkrMzV5SUZNZlRJejlCVlpRa0NBd0VBQVE9PQotLS0tLUVORCBSU0EgUFVCTElDIEtFWS0tLS0tCg=="
          },
          "enabled": {
            "description": "Enable or disable the visualization server.\n\nThis flag can be used to easily enable or disable the server\nwithout removing the configuration. Default is `true`.",
            "type": "boolean",
            "default": true
          },
          "session_secret": {
            "description": "Session secret key for cookie-based authentication.",
            "type": "string",
            "default": "LsVHHRWynGuH7+1z7cNlo8RmmxpWG3Nc1/YYZOVhKTM="
          },
          "enable_compression": {
            "description": "Optional enable compression for the server responses.\nThis can help reduce the size of the data sent over the network,\nimproving performance for large responses.\nDefault is `true`, meaning compression is enabled.",
            "type": "boolean",
            "default": true
          },
          "output": {
            "description": "List of output items to be displayed in the visualization interface.\n\nEach item represents a specific measurement with customizable display properties.\nThe order of items in this list determines their display order in the interface.\nItems with negative display order values will be hidden.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VisualizationOutputItem"
            },
            "default": []
          }
        }
      },
      "VisualizationOutputItem": {
        "description": "Configuration item for visualization output display\n\nEach item represents a specific measurement that will be displayed\nin the visualization interface, with customizable properties.",
        "type": "object",
        "properties": {
          "id": {
            "description": "Unique identifier for this output configuration",
            "type": "string"
          },
          "action_node_id": {
            "description": "ID of the action node providing the measurement data",
            "type": "string"
          },
          "molecule": {
            "description": "Name of the molecule being measured (e.g., \"H₂S\", \"CO₂\", \"CH₄\")",
            "type": "string"
          },
          "unit": {
            "description": "Unit of measurement (e.g., \"ppm\", \"mg/m³\", \"%\")",
            "type": "string"
          },
          "display_order": {
            "description": "Display order in the interface (negative values hide the item)",
            "type": "integer",
            "format": "int32"
          },
          "description": {
            "description": "Description of the measurement (e.g., \"Spectral ray 3963nm\")",
            "type": "string"
          },
          "concentration_min": {
            "description": "Minimal concentration value to display (below this value, the item is hidden)",
            "type": "number",
            "format": "double"
          },
          "concentration_max": {
            "description": "Maximum concentration value to display (above this value, the item is hidden)",
            "type": "number",
            "format": "double"
          }
        },
        "required": [
          "id",
          "action_node_id",
          "molecule",
          "unit",
          "display_order",
          "description",
          "concentration_min",
          "concentration_max"
        ]
      },
      "AcquisitionConfig": {
        "description": "Configuration for the data acquisition process.\n\nThis structure contains settings that control how data is acquired\nfrom the photoacoustic sensor, including timing parameters and\nwhether the acquisition system is enabled.",
        "type": "object",
        "properties": {
          "enabled": {
            "description": "Flag to enable or disable data acquisition.\n\nWhen enabled, the system will acquire data from the configured source\nat the specified interval. When disabled, no data is acquired.",
            "type": "boolean"
          },
          "interval_ms": {
            "description": "Time interval in milliseconds between acquisitions.\n\nThis parameter controls how frequently the system will acquire new data.\nLower values provide more frequent updates but may increase system load.\nMust be greater than zero.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          }
        },
        "required": [
          "enabled",
          "interval_ms"
        ]
      },
      "ModbusConfig": {
        "description": "Configuration for the Modbus TCP server component.\n\nThis structure contains settings that control the Modbus TCP server functionality,\nincluding network binding parameters and whether the server is enabled.\n\n### Fields\n\n* `enabled` - Flag to enable or disable the Modbus server\n* `port` - TCP port number for the Modbus server (default: 502)\n* `address` - Network address for the Modbus server to bind to (default: 127.0.0.1)\n\n### Example\n\n```\nuse rust_photoacoustic::config::ModbusConfig;\n\nlet modbus_config = ModbusConfig {\n    enabled: true,\n    port: 503,\n    address: \"0.0.0.0\".to_string(),\n};\n```",
        "type": "object",
        "properties": {
          "enabled": {
            "description": "Flag to enable or disable the Modbus server.\n\nWhen enabled, the server will start and respond to Modbus TCP requests.\nWhen disabled, no server will be started and no resources will be used.",
            "type": "boolean"
          },
          "port": {
            "description": "The TCP port the Modbus server will listen on.\n\nValid range is 1-65534. Default value is 502, which is the standard Modbus TCP port.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0,
            "maximum": 65535
          },
          "address": {
            "description": "The network address the Modbus server will bind to.\n\nCan be an IPv4/IPv6 address or a hostname. Default is \"127.0.0.1\".\nUse \"0.0.0.0\" to bind to all IPv4 interfaces.",
            "type": "string"
          }
        },
        "required": [
          "enabled",
          "port",
          "address"
        ]
      },
      "PhotoacousticConfig": {
        "description": "Configuration for the photoacoustic measurement system.\n\nThis structure contains settings that control the photoacoustic measurement process,\nincluding input sources, signal processing parameters, and analysis settings.\n\n### Input Sources\n\nThe configuration supports two mutually exclusive input sources:\n* `input_device` - A hardware audio device (e.g., \"hw:0,0\" for ALSA) \"first\" for the first available device\n* `input_file` - A path to a WAV file for offline analysis\n\nOne of these must be specified, but not both simultaneously.\n\n### Signal Processing Parameters\n\n* `frequency` - The primary excitation frequency in Hz\n* `bandwidth` - Filter bandwidth in Hz around the excitation frequency\n* `frame_size` - FFT window size (power of 2 recommended)\n* `averages` - Number of spectra to average for noise reduction\n\n### Example\n\n```no_run\nuse rust_photoacoustic::config::{PhotoacousticConfig, SimulatedSourceConfig};\n\nlet pa_config = PhotoacousticConfig {\n    input_device: Some(\"first\".to_string()),\n    input_file: None,\n    frequency: 1000.0,\n    sample_rate: 48000,\n    bandwidth: 50.0,\n    frame_size: 4096,\n    averages: 10,\n    precision: 16,\n    simulated_source: Some(SimulatedSourceConfig::default()),\n    record_consumer: false,\n    record_file: \"recorded_audio.wav\".to_string(),\n};\n```",
        "type": "object",
        "properties": {
          "input_device": {
            "description": "The input device to use for data acquisition",
            "type": "string",
            "nullable": true
          },
          "input_file": {
            "description": "The input file to use for data acquisition mutually exclusive with input_device",
            "type": "string",
            "nullable": true
          },
          "simulated_source": {
            "description": "Configuration for simulated photoacoustic sources\n\nWhen present, enables simulation mode using either the simple mock source\nor the comprehensive universal photoacoustic generator. This replaces the\ndeprecated `mock_source` and `mock_correlation` parameters.\n\n**For Physics PhD Specialists:**\nThe simulated source can model realistic photoacoustic phenomena including\nHelmholtz resonance, gas flow noise, thermal effects, and dual-microphone\ndifferential configurations.\n\n**For Developers:**\nWhen `simulated_source` is `Some(config)`, the acquisition system will use\nsynthetic data instead of hardware input. When `None`, real hardware sources\nare used.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatedSourceConfig"
              },
              {
                "nullable": true,
                "enum": [
                  null
                ]
              }
            ]
          },
          "frequency": {
            "description": "The excitation frequency in Hz",
            "type": "number",
            "format": "float"
          },
          "bandwidth": {
            "description": "Filter bandwidth in Hz",
            "type": "number",
            "format": "float"
          },
          "frame_size": {
            "description": "Window size for FFT analysis and frame sharing",
            "type": "integer",
            "format": "uint16",
            "minimum": 0,
            "maximum": 65535
          },
          "averages": {
            "description": "Number of spectra to average",
            "type": "integer",
            "format": "uint16",
            "minimum": 0,
            "maximum": 65535
          },
          "sample_rate": {
            "description": "Sample rate of the input data (default is 48000 Hz)",
            "type": "integer",
            "format": "uint16",
            "minimum": 0,
            "maximum": 65535,
            "default": 44100
          },
          "precision": {
            "description": "Sampling precision in bits (16 bits for standard PCM)",
            "type": "integer",
            "format": "uint8",
            "minimum": 0,
            "maximum": 255,
            "default": 16
          },
          "record_consumer": {
            "description": "Flag to enable or disable the record consumer daemon.\n\nWhen enabled, a record consumer will be started to validate the producer/consumer\nsystem by consuming audio frames and saving them to a WAV file.",
            "type": "boolean",
            "default": false
          },
          "record_file": {
            "description": "Optional output file for recording audio frames",
            "type": "string",
            "default": ""
          }
        },
        "required": [
          "frequency",
          "bandwidth",
          "frame_size",
          "averages"
        ]
      },
      "SimulatedSourceConfig": {
        "description": "Configuration for simulated photoacoustic sources\n\nThis structure configures all parameters for generating synthetic photoacoustic signals\nusing either the simple mock approach or the comprehensive universal photoacoustic\nsimulation. It supports both the existing `MockSource` and the new\n`SimulatedPhotoacousticRealtimeAudioSource`.\n\n### Physics Parameters\n\n**For Physics PhD Specialists:**\nThe configuration models a Helmholtz resonance cell photoacoustic analyzer with:\n- Resonance frequency typically around 2 kHz for optimal acoustic coupling\n- Dual microphone differential configuration for noise rejection\n- Laser modulation creating photoacoustic waves through molecular absorption\n- Gas flow introducing 1/f noise characteristics\n- Temperature effects causing frequency and phase drift\n- SNR control for signal quality assessment\n\n**For Rust Developers:**\nThis structure provides all parameters needed to configure the `generate_universal_photoacoustic_stereo`\nfunction, with sensible defaults for typical photoacoustic measurement scenarios.\n\n### Examples\n\n```no_run\nuse rust_photoacoustic::config::SimulatedSourceConfig;\n\n// Configuration for simple mock source\nlet mock_config = SimulatedSourceConfig {\n    source_type: \"mock\".to_string(),\n    correlation: 0.8,\n    ..Default::default()\n};\n\n// Configuration for comprehensive physics simulation\nlet universal_config = SimulatedSourceConfig {\n    source_type: \"universal\".to_string(),\n    background_noise_amplitude: 0.1,\n    resonance_frequency: 2100.0,\n    laser_modulation_depth: 0.9,\n    signal_amplitude: 0.7,\n    phase_opposition_degrees: 175.0,\n    temperature_drift_factor: 0.02,\n    gas_flow_noise_factor: 0.3,\n    snr_factor: 25.0,\n    modulation_mode: \"amplitude\".to_string(),\n    pulse_width_seconds: 0.005,\n    pulse_frequency_hz: 100.0,\n    ..Default::default()\n};\n```",
        "type": "object",
        "properties": {
          "source_type": {
            "description": "Source type: \"mock\" for simple MockSource or \"universal\" for full physics simulation\n\n**Source Options:**\n- \"mock\": Uses the existing `MockSource` with simple correlation-based signal generation\n- \"universal\": Uses the new `SimulatedPhotoacousticRealtimeAudioSource` with comprehensive\n  physics simulation including Helmholtz resonance, gas flow noise, and thermal drift\n\n**For Physics PhD Specialists:**\nUse \"mock\" for quick testing and \"universal\" for realistic photoacoustic physics modeling.\n\n**For Rust Developers:**\n\"mock\" provides lightweight simulation, \"universal\" provides full feature simulation.",
            "type": "string",
            "default": "mock"
          },
          "correlation": {
            "description": "Correlation coefficient between channels for simple mock mode (0.0 to 1.0)\n\nThis parameter is used by the existing `MockSource` for backward compatibility.\nIt controls the statistical correlation between left and right channels:\n- 1.0: Perfectly correlated (identical channels)\n- 0.0: Uncorrelated (independent channels)\nOnly used when source_type is \"mock\".",
            "type": "number",
            "format": "float",
            "default": 0.699999988079071
          },
          "background_noise_amplitude": {
            "description": "Background noise amplitude for gas flow and environmental noise (0.0 to 1.0)\n\nControls the amplitude of background noise including:\n- Gas flow turbulence (1/f characteristics)\n- Environmental acoustic interference\n- Electronic noise in the measurement system",
            "type": "number",
            "format": "float",
            "default": 0.15000000596046448
          },
          "resonance_frequency": {
            "description": "Resonance frequency of the Helmholtz cell in Hz\n\n**Physics Background:**\nThe Helmholtz resonance frequency is determined by the cell geometry and gas properties.\nTypical values range from 1.5 to 3 kHz for optimal photoacoustic coupling.\nThe resonance enhances the photoacoustic signal at this frequency.",
            "type": "number",
            "format": "float",
            "default": 2100.0
          },
          "laser_modulation_depth": {
            "description": "Laser modulation depth (0.0 to 1.0)\n\nControls the depth of laser intensity modulation creating the photoacoustic effect.\nHigher values produce stronger photoacoustic signals but may introduce nonlinearities.",
            "type": "number",
            "format": "float",
            "default": 0.800000011920929
          },
          "signal_amplitude": {
            "description": "Photoacoustic signal amplitude (0.0 to 1.0)\n\nSets the overall amplitude of the photoacoustic signal relative to background noise.\nThis represents the signal strength that would be observed with a given analyte concentration.",
            "type": "number",
            "format": "float",
            "default": 0.6000000238418579
          },
          "phase_opposition_degrees": {
            "description": "Phase opposition between microphones in degrees\n\n**Physics Background:**\nIn a differential photoacoustic cell, microphones are positioned to be in approximate\nphase opposition (180°). Small deviations (170-185°) are realistic due to:\n- Manufacturing tolerances in microphone positioning\n- Temperature-induced changes in gas properties\n- Cell geometry variations",
            "type": "number",
            "format": "float",
            "default": 175.0
          },
          "temperature_drift_factor": {
            "description": "Temperature drift factor affecting phase and frequency stability (0.0 to 0.1)\n\n**Physics Background:**\nTemperature variations affect:\n- Gas density and sound velocity (frequency drift)\n- Thermal expansion of cell components (phase drift)\n- Molecular absorption characteristics\nTypical values: 0.01-0.05 for laboratory conditions",
            "type": "number",
            "format": "float",
            "default": 0.019999999552965164
          },
          "gas_flow_noise_factor": {
            "description": "Gas flow noise factor for 1/f characteristics (0.0 to 1.0)\n\n**Physics Background:**\nGas circulation in photoacoustic cells introduces characteristic 1/f noise due to:\n- Turbulent flow patterns\n- Pressure fluctuations\n- Flow-induced vibrations\nHigher values simulate more turbulent conditions.",
            "type": "number",
            "format": "float",
            "default": 0.30000001192092896
          },
          "snr_factor": {
            "description": "Signal-to-noise ratio factor in dB\n\nControls the overall signal quality by setting the ratio between the\nphotoacoustic signal and background noise. Typical values:\n- 10-20 dB: Poor conditions (high noise environment)\n- 20-30 dB: Normal operation\n- 30+ dB: Excellent conditions (low noise, high concentration)",
            "type": "number",
            "format": "float",
            "default": 25.0
          },
          "modulation_mode": {
            "description": "Laser modulation mode: \"amplitude\" or \"pulsed\"\n\n**Physics Background:**\n- \"amplitude\": Continuous amplitude modulation at resonance frequency\n- \"pulsed\": Periodic pulsed operation with configurable pulse width and frequency\n\nPulsed mode allows for different measurement techniques and can provide\nbetter temporal resolution for concentration measurements.",
            "type": "string",
            "default": "amplitude"
          },
          "pulse_width_seconds": {
            "description": "Pulse width in seconds (for pulsed mode)\n\nDuration of each laser pulse when using pulsed modulation mode.\nTypical values: 0.001-0.01 seconds (1-10 ms)",
            "type": "number",
            "format": "float",
            "default": 0.004999999888241291
          },
          "pulse_frequency_hz": {
            "description": "Pulse frequency in Hz (for pulsed mode)\n\nRepetition rate of laser pulses when using pulsed modulation mode.\nShould be much lower than the resonance frequency.\nTypical values: 10-1000 Hz",
            "type": "number",
            "format": "float",
            "default": 100.0
          }
        }
      },
      "AccessConfig": {
        "description": "Configuration for user access and permissions\n\nThis structure defines both users who can access the application directly\nand OAuth2 clients that can use the authorization flow. Users have usernames,\npassword hashes, and permissions, while clients have identifiers and allowed\ncallback URLs.\n\n### Example\n\n```rust\nuse rust_photoacoustic::config::access::{AccessConfig, User, Client};\n\nlet access_config = AccessConfig {\n    duration: Some(86400), // Token duration in seconds\n    iss: Some(\"LaserSmartServer\".to_string()),\n    users: vec![\n         User {\n             user: \"admin\".to_string(),\n             pass: \"JDEkYTRuMy5jZmUkRU93djlOYXBKYjFNTXRTMHA1UzN1MQo=\".to_string(),\n             permissions: vec![\"read:api\".to_string(), \"write:api\".to_string(), \"admin:api\".to_string()],\n             email: None,\n             name: None,\n         },\n         User {\n             user: \"reader\".to_string(),\n             pass: \"JDEkUTJoSGZWU3ckT3NIVTUzamhCY3pYVmRHTGlTazg4Lwo=\".to_string(),\n             permissions: vec![\"read:api\".to_string()],\n             email: None,\n             name: None,\n         }],\n     clients: vec![\n         Client {\n             client_id: \"LaserSmartClient\".to_string(),\n             default_scope: \"openid profile email read:api write:api\".to_string(),\n             allowed_callbacks: vec![\n                 \"http://localhost:8080/client/\".to_string(),\n                 \"https://localhost:8080/client/\".to_string(),\n             ],\n         }],\n    };\n```",
        "type": "object",
        "properties": {
          "users": {
            "description": "List of users with their credentials and permissions",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/User"
            }
          },
          "clients": {
            "description": "List of OAuth2 clients with their identifiers and allowed callback URLs",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Client"
            }
          },
          "duration": {
            "description": "Duration of the issued token",
            "type": "integer",
            "format": "int64",
            "default": 86400,
            "nullable": true
          },
          "iss": {
            "description": "Issuer for the access tokens",
            "type": "string",
            "default": "LaserSmartServer",
            "nullable": true
          }
        },
        "required": [
          "users",
          "clients"
        ]
      },
      "User": {
        "description": "User definition for authentication and authorization\n\nThis structure represents a user with authentication credentials and\nassociated permissions for controlling access to API endpoints.\n\n### Fields\n\n* `user` - The username used for authentication\n* `pass` - Base64-encoded password hash (created with openssl passwd -5 | base64 -w0)\n* `permissions` - List of permission strings that define what actions the user can perform\n\n### Example\n\n```\nuse rust_photoacoustic::config::User;\n\nlet user = User {\n    user: \"admin\".to_string(),\n    pass: \"JDEkYTRuMy5jZmUkRU93djlOYXBKYjFNTXRTMHA1UzN1MQo=\".to_string(),\n    email: None,\n    name: None,\n    permissions: vec![\"read:api\".to_string(), \"write:api\".to_string(), \"admin:api\".to_string()],\n};\n```",
        "type": "object",
        "properties": {
          "user": {
            "description": "The username used for authentication",
            "type": "string"
          },
          "pass": {
            "description": "Base64-encoded password hash\n\nThis should be created using: `openssl passwd -5 <password> | base64 -w0`",
            "type": "string"
          },
          "permissions": {
            "description": "List of permission strings that define what actions the user can perform\n\nCommon permissions include:\n* \"read:api\" - Allows read-only access to API endpoints\n* \"write:api\" - Allows modification operations on API endpoints\n* \"admin:api\" - Allows administrative operations",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "email": {
            "type": "string",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          }
        },
        "required": [
          "user",
          "pass",
          "permissions"
        ]
      },
      "Client": {
        "description": "OAuth2 client configuration for authorization code flow\n\nThis structure represents an OAuth2 client that is allowed to use\nthe authorization code flow with this server.\n\n### Fields\n\n* `client_id` - The unique identifier for the OAuth2 client\n* `allowed_callbacks` - List of URLs that this client is allowed to redirect to\n\n### Example\n\n```\nuse rust_photoacoustic::config::access::Client;\n\nlet client = Client {\n    client_id: \"LaserSmartClient\".to_string(),\n    default_scope: \"openid profile email read:api write:api\".to_string(),\n    allowed_callbacks: vec![\n        \"http://localhost:8080/client/\".to_string(),\n        \"https://localhost:8080/client/\".to_string(),\n    ],\n};\n```",
        "type": "object",
        "properties": {
          "client_id": {
            "description": "The unique identifier for the OAuth2 client",
            "type": "string"
          },
          "allowed_callbacks": {
            "description": "List of URLs that this client is allowed to redirect to after authorization\n\nThese URLs must match exactly during the OAuth2 flow for security.\nBoth HTTP and HTTPS URLs are supported, but HTTPS is recommended for production.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "default_scope": {
            "description": "Default scope for the client\n\nThis is a space-separated list of scopes that the client can request.\nThe default scope is used if the client does not specify a scope during the authorization request.",
            "type": "string"
          }
        },
        "required": [
          "client_id",
          "allowed_callbacks",
          "default_scope"
        ]
      },
      "ProcessingConfig": {
        "description": "Configuration for the processing system",
        "type": "object",
        "properties": {
          "enabled": {
            "description": "Enable or disable the processing consumer",
            "type": "boolean",
            "default": true
          },
          "result_buffer_size": {
            "description": "Buffer size for processing results broadcasting",
            "type": "integer",
            "format": "uint",
            "minimum": 0,
            "default": 1000
          },
          "default_graph": {
            "description": "Default processing graph configuration",
            "default": {
              "id": "default",
              "nodes": [
                {
                  "id": "input",
                  "node_type": "input",
                  "parameters": null
                },
                {
                  "id": "channel_selector",
                  "node_type": "channel_selector",
                  "parameters": {
                    "target_channel": "ChannelA"
                  }
                }
              ],
              "connections": [
                {
                  "from": "input",
                  "to": "channel_selector"
                }
              ],
              "output_node": "channel_selector"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ProcessingGraphConfig"
              }
            ]
          },
          "performance": {
            "description": "Processing performance settings",
            "default": {
              "max_processing_time_us": 10000,
              "enable_stats": true,
              "stats_interval_ms": 1000
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ProcessingPerformanceConfig"
              }
            ]
          }
        }
      },
      "ProcessingGraphConfig": {
        "description": "Configuration for a processing graph",
        "type": "object",
        "properties": {
          "id": {
            "description": "Graph identifier",
            "type": "string",
            "default": "default"
          },
          "nodes": {
            "description": "List of nodes in the graph",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NodeConfig"
            },
            "default": []
          },
          "connections": {
            "description": "List of connections between nodes",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConnectionConfig"
            },
            "default": []
          },
          "output_node": {
            "description": "Output node identifier",
            "type": "string",
            "default": null,
            "nullable": true
          }
        }
      },
      "NodeConfig": {
        "description": "Configuration for a processing node",
        "type": "object",
        "properties": {
          "id": {
            "description": "Node identifier",
            "type": "string"
          },
          "node_type": {
            "description": "Node type (filter, differential, channel_selector, etc.)",
            "type": "string"
          },
          "parameters": {
            "description": "Node-specific parameters",
            "default": null
          }
        },
        "required": [
          "id",
          "node_type"
        ]
      },
      "ConnectionConfig": {
        "description": "Configuration for a connection between nodes",
        "type": "object",
        "properties": {
          "from": {
            "description": "Source node identifier",
            "type": "string"
          },
          "to": {
            "description": "Target node identifier",
            "type": "string"
          }
        },
        "required": [
          "from",
          "to"
        ]
      },
      "ProcessingPerformanceConfig": {
        "description": "Performance configuration for processing",
        "type": "object",
        "properties": {
          "max_processing_time_us": {
            "description": "Maximum processing time per frame (microseconds)",
            "type": "integer",
            "format": "uint64",
            "minimum": 0,
            "default": 10000
          },
          "enable_stats": {
            "description": "Enable detailed processing statistics",
            "type": "boolean",
            "default": true
          },
          "stats_interval_ms": {
            "description": "Statistics update interval (milliseconds)",
            "type": "integer",
            "format": "uint64",
            "minimum": 0,
            "default": 1000
          }
        }
      },
      "ThermalRegulationConfig": {
        "description": "Main thermal regulation configuration",
        "type": "object",
        "properties": {
          "enabled": {
            "description": "Enable or disable thermal regulation system",
            "type": "boolean",
            "default": false
          },
          "i2c_buses": {
            "description": "I2C bus configurations (primary and optional secondary buses)",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/I2CBusConfig"
            }
          },
          "regulators": {
            "description": "Individual thermal regulators configuration",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ThermalRegulatorConfig"
            },
            "default": []
          },
          "global_settings": {
            "description": "Global thermal regulation parameters",
            "default": {
              "global_sampling_rate_hz": 10.0,
              "max_concurrent_regulators": 32,
              "resource_sharing": {
                "i2c_arbitration_timeout_ms": 100,
                "max_operation_queue_size": 100,
                "priority_scheduling": false
              },
              "monitoring": {
                "enable_performance_monitoring": true,
                "metrics_interval_s": 1.0,
                "enable_thermal_history": false,
                "history_buffer_size": 1000
              }
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/GlobalThermalSettings"
              }
            ]
          }
        },
        "required": [
          "i2c_buses"
        ]
      },
      "I2CBusConfig": {
        "description": "I2C bus configuration for hardware controllers",
        "type": "object",
        "properties": {
          "type": {
            "description": "Bus type: \"native\" for Raspberry Pi I2C or \"cp2112\" for USB-HID bridge",
            "allOf": [
              {
                "$ref": "#/components/schemas/I2CBusType"
              }
            ]
          },
          "device": {
            "description": "Device path for native I2C (e.g., \"/dev/i2c-1\") or USB identifier for CP2112",
            "type": "string"
          },
          "usb_vendor_id": {
            "description": "USB vendor ID for CP2112 (only used when bus_type is \"cp2112\")",
            "type": "integer",
            "format": "uint16",
            "minimum": 0,
            "maximum": 65535,
            "nullable": true
          },
          "usb_product_id": {
            "description": "USB product ID for CP2112 (only used when bus_type is \"cp2112\")",
            "type": "integer",
            "format": "uint16",
            "minimum": 0,
            "maximum": 65535,
            "nullable": true
          },
          "pwm_controllers": {
            "description": "PWM controllers on this bus (up to 32 PCA9685)",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PwmControllerConfig"
            },
            "default": []
          },
          "adc_controllers": {
            "description": "ADC controllers on this bus (up to 4 ADS1115)",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AdcControllerConfig"
            },
            "default": []
          },
          "gpio_controllers": {
            "description": "GPIO controllers on this bus (up to 8 CAT9555)",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GpioControllerConfig"
            },
            "default": []
          },
          "bus_settings": {
            "description": "Bus-specific settings",
            "default": {
              "frequency_hz": 100000,
              "timeout_ms": 1000,
              "max_retries": 3
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/I2CBusSettings"
              }
            ]
          }
        },
        "required": [
          "type",
          "device"
        ]
      },
      "I2CBusType": {
        "description": "I2C bus type enumeration",
        "oneOf": [
          {
            "description": "Native Raspberry Pi I2C bus",
            "type": "string",
            "enum": [
              "native"
            ]
          },
          {
            "description": "Silicon Labs CP2112 USB-to-I2C bridge",
            "type": "string",
            "enum": [
              "cp2112"
            ]
          },
          {
            "description": "Mock driver for thermal simulation testing",
            "type": "string",
            "enum": [
              "mock"
            ]
          }
        ]
      },
      "PwmControllerConfig": {
        "description": "PWM controller configuration (PCA9685)",
        "type": "object",
        "properties": {
          "address": {
            "description": "I2C address of the PCA9685 controller (0x40-0x7F)",
            "type": "integer",
            "format": "uint8",
            "minimum": 0,
            "maximum": 255
          },
          "channels": {
            "description": "Number of PWM channels (always 16 for PCA9685)",
            "type": "integer",
            "format": "uint8",
            "minimum": 0,
            "maximum": 255,
            "default": 16
          },
          "frequency_hz": {
            "description": "PWM frequency in Hz (24-1526 Hz for PCA9685)",
            "type": "integer",
            "format": "uint16",
            "minimum": 0,
            "maximum": 65535,
            "default": 1000
          },
          "settings": {
            "description": "Controller-specific settings",
            "default": {
              "auto_increment": false,
              "sleep_mode": false,
              "restart_mode": false
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/PwmControllerSettings"
              }
            ]
          }
        },
        "required": [
          "address"
        ]
      },
      "PwmControllerSettings": {
        "description": "PWM controller settings",
        "type": "object",
        "properties": {
          "auto_increment": {
            "description": "Enable auto-increment mode",
            "type": "boolean",
            "default": false
          },
          "sleep_mode": {
            "description": "Sleep mode configuration",
            "type": "boolean",
            "default": false
          },
          "restart_mode": {
            "description": "Restart mode configuration",
            "type": "boolean",
            "default": false
          }
        }
      },
      "AdcControllerConfig": {
        "description": "ADC controller configuration (ADS1115)",
        "type": "object",
        "properties": {
          "address": {
            "description": "I2C address of the ADS1115 controller (0x48-0x4B)",
            "type": "integer",
            "format": "uint8",
            "minimum": 0,
            "maximum": 255
          },
          "channels": {
            "description": "Number of ADC channels (always 4 for ADS1115)",
            "type": "integer",
            "format": "uint8",
            "minimum": 0,
            "maximum": 255,
            "default": 4
          },
          "resolution": {
            "description": "ADC resolution in bits (always 16 for ADS1115)",
            "type": "integer",
            "format": "uint8",
            "minimum": 0,
            "maximum": 255,
            "default": 16
          },
          "voltage_ref": {
            "description": "Voltage reference in volts",
            "type": "number",
            "format": "float",
            "default": 3.299999952316284
          },
          "gain": {
            "description": "ADC gain setting",
            "default": "GAIN_TWO",
            "allOf": [
              {
                "$ref": "#/components/schemas/AdcGain"
              }
            ]
          },
          "data_rate": {
            "description": "Data rate in samples per second",
            "default": "Sps128",
            "allOf": [
              {
                "$ref": "#/components/schemas/AdcDataRate"
              }
            ]
          }
        },
        "required": [
          "address"
        ]
      },
      "AdcGain": {
        "description": "ADC gain settings for ADS1115",
        "oneOf": [
          {
            "description": "±6.144V range",
            "type": "string",
            "enum": [
              "GAIN_TWOTHIRDS"
            ]
          },
          {
            "description": "±4.096V range",
            "type": "string",
            "enum": [
              "GAIN_ONE"
            ]
          },
          {
            "description": "±2.048V range (default)",
            "type": "string",
            "enum": [
              "GAIN_TWO"
            ]
          },
          {
            "description": "±1.024V range",
            "type": "string",
            "enum": [
              "GAIN_FOUR"
            ]
          },
          {
            "description": "±0.512V range",
            "type": "string",
            "enum": [
              "GAIN_EIGHT"
            ]
          },
          {
            "description": "±0.256V range",
            "type": "string",
            "enum": [
              "GAIN_SIXTEEN"
            ]
          }
        ]
      },
      "AdcDataRate": {
        "description": "ADC data rate settings for ADS1115",
        "oneOf": [
          {
            "description": "8 samples per second",
            "type": "string",
            "enum": [
              "Sps8"
            ]
          },
          {
            "description": "16 samples per second",
            "type": "string",
            "enum": [
              "Sps16"
            ]
          },
          {
            "description": "32 samples per second",
            "type": "string",
            "enum": [
              "Sps32"
            ]
          },
          {
            "description": "64 samples per second",
            "type": "string",
            "enum": [
              "Sps64"
            ]
          },
          {
            "description": "128 samples per second (default)",
            "type": "string",
            "enum": [
              "Sps128"
            ]
          },
          {
            "description": "250 samples per second",
            "type": "string",
            "enum": [
              "Sps250"
            ]
          },
          {
            "description": "475 samples per second",
            "type": "string",
            "enum": [
              "Sps475"
            ]
          },
          {
            "description": "860 samples per second",
            "type": "string",
            "enum": [
              "Sps860"
            ]
          }
        ]
      },
      "GpioControllerConfig": {
        "description": "GPIO controller configuration (CAT9555)",
        "type": "object",
        "properties": {
          "address": {
            "description": "I2C address of the CAT9555 controller (0x20-0x27)",
            "type": "integer",
            "format": "uint8",
            "minimum": 0,
            "maximum": 255
          },
          "channels": {
            "description": "Number of GPIO channels (always 16 for CAT9555)",
            "type": "integer",
            "format": "uint8",
            "minimum": 0,
            "maximum": 255,
            "default": 16
          },
          "type": {
            "description": "Controller type identifier",
            "type": "string",
            "default": "CAT9555"
          },
          "function": {
            "description": "Primary function of this GPIO controller",
            "default": "h_bridge_control",
            "allOf": [
              {
                "$ref": "#/components/schemas/GpioFunction"
              }
            ]
          },
          "settings": {
            "description": "GPIO controller settings",
            "default": {
              "polarity_inversion": 0,
              "interrupt_config": {
                "enabled": false,
                "pin_config": 0
              }
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/GpioControllerSettings"
              }
            ]
          }
        },
        "required": [
          "address"
        ]
      },
      "GpioFunction": {
        "description": "GPIO controller function",
        "oneOf": [
          {
            "description": "H-Bridge control for thermal regulation",
            "type": "string",
            "enum": [
              "h_bridge_control"
            ]
          },
          {
            "description": "General purpose I/O",
            "type": "string",
            "enum": [
              "general_purpose"
            ]
          },
          {
            "description": "Status indication (LEDs, etc.)",
            "type": "string",
            "enum": [
              "status_indication"
            ]
          }
        ]
      },
      "GpioControllerSettings": {
        "description": "GPIO controller settings",
        "type": "object",
        "properties": {
          "polarity_inversion": {
            "description": "Input polarity inversion",
            "type": "integer",
            "format": "uint16",
            "minimum": 0,
            "maximum": 65535,
            "default": 0
          },
          "interrupt_config": {
            "description": "Interrupt configuration",
            "default": {
              "enabled": false,
              "pin_config": 0
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/InterruptConfig"
              }
            ]
          }
        }
      },
      "InterruptConfig": {
        "description": "Interrupt configuration for GPIO controllers",
        "type": "object",
        "properties": {
          "enabled": {
            "description": "Enable interrupts",
            "type": "boolean",
            "default": false
          },
          "pin_config": {
            "description": "Interrupt pin configuration",
            "type": "integer",
            "format": "uint16",
            "minimum": 0,
            "maximum": 65535,
            "default": 0
          }
        }
      },
      "I2CBusSettings": {
        "description": "I2C bus settings",
        "type": "object",
        "properties": {
          "frequency_hz": {
            "description": "I2C clock frequency in Hz",
            "type": "integer",
            "format": "uint32",
            "minimum": 0,
            "default": 100000
          },
          "timeout_ms": {
            "description": "Bus timeout in milliseconds",
            "type": "integer",
            "format": "uint32",
            "minimum": 0,
            "default": 1000
          },
          "max_retries": {
            "description": "Maximum retry attempts for failed operations",
            "type": "integer",
            "format": "uint8",
            "minimum": 0,
            "maximum": 255,
            "default": 3
          }
        }
      },
      "ThermalRegulatorConfig": {
        "description": "Individual thermal regulator configuration",
        "type": "object",
        "properties": {
          "id": {
            "description": "Unique identifier for this regulator",
            "type": "string"
          },
          "name": {
            "description": "Human-readable name for this regulator",
            "type": "string"
          },
          "enabled": {
            "description": "Enable or disable this specific regulator",
            "type": "boolean",
            "default": true
          },
          "i2c_bus": {
            "description": "I2C bus identifier (reference to i2c_buses key)",
            "type": "string"
          },
          "temperature_sensor": {
            "description": "Temperature sensor configuration",
            "allOf": [
              {
                "$ref": "#/components/schemas/TemperatureSensorConfig"
              }
            ]
          },
          "actuators": {
            "description": "Thermal actuators configuration",
            "allOf": [
              {
                "$ref": "#/components/schemas/ThermalActuatorsConfig"
              }
            ]
          },
          "temperature_conversion": {
            "description": "Temperature conversion parameters",
            "allOf": [
              {
                "$ref": "#/components/schemas/TemperatureConversionConfig"
              }
            ]
          },
          "pid_parameters": {
            "description": "PID controller parameters",
            "allOf": [
              {
                "$ref": "#/components/schemas/PidParameters"
              }
            ]
          },
          "control_parameters": {
            "description": "Control system parameters",
            "allOf": [
              {
                "$ref": "#/components/schemas/ControlParameters"
              }
            ]
          },
          "safety_limits": {
            "description": "Safety limits and protections",
            "allOf": [
              {
                "$ref": "#/components/schemas/SafetyLimits"
              }
            ]
          }
        },
        "required": [
          "id",
          "name",
          "i2c_bus",
          "temperature_sensor",
          "actuators",
          "temperature_conversion",
          "pid_parameters",
          "control_parameters",
          "safety_limits"
        ]
      },
      "TemperatureSensorConfig": {
        "description": "Temperature sensor configuration",
        "type": "object",
        "properties": {
          "adc_address": {
            "description": "ADC controller I2C address",
            "type": "integer",
            "format": "uint8",
            "minimum": 0,
            "maximum": 255
          },
          "adc_channel": {
            "description": "ADC channel number (0-3)",
            "type": "integer",
            "format": "uint8",
            "minimum": 0,
            "maximum": 255
          },
          "sensor_type": {
            "description": "Sensor type for calibration",
            "default": "generic",
            "allOf": [
              {
                "$ref": "#/components/schemas/TemperatureSensorType"
              }
            ]
          }
        },
        "required": [
          "adc_address",
          "adc_channel"
        ]
      },
      "TemperatureSensorType": {
        "description": "Temperature sensor types",
        "oneOf": [
          {
            "description": "Thermocouple (Type K)",
            "type": "string",
            "enum": [
              "thermocouple_k"
            ]
          },
          {
            "description": "Thermocouple (Type J)",
            "type": "string",
            "enum": [
              "thermocouple_j"
            ]
          },
          {
            "description": "RTD (PT100)",
            "type": "string",
            "enum": [
              "rtd_pt100"
            ]
          },
          {
            "description": "RTD (PT1000)",
            "type": "string",
            "enum": [
              "rtd_pt1000"
            ]
          },
          {
            "description": "Thermistor (NTC)",
            "type": "string",
            "enum": [
              "thermistor_ntc"
            ]
          },
          {
            "description": "Generic voltage sensor",
            "type": "string",
            "enum": [
              "generic"
            ]
          }
        ]
      },
      "ThermalActuatorsConfig": {
        "description": "Thermal actuators configuration with H-Bridge control",
        "type": "object",
        "properties": {
          "thermal_control": {
            "description": "Main thermal control configuration",
            "allOf": [
              {
                "$ref": "#/components/schemas/ThermalControlConfig"
              }
            ]
          }
        },
        "required": [
          "thermal_control"
        ]
      },
      "ThermalControlConfig": {
        "description": "Thermal control configuration for bidirectional control",
        "type": "object",
        "properties": {
          "pwm_controller": {
            "description": "PWM controller configuration",
            "allOf": [
              {
                "$ref": "#/components/schemas/PwmChannelConfig"
              }
            ]
          },
          "direction_controller": {
            "description": "Direction controller (GPIO) configuration",
            "allOf": [
              {
                "$ref": "#/components/schemas/DirectionControllerConfig"
              }
            ]
          },
          "thermal_modes": {
            "description": "Available thermal modes",
            "allOf": [
              {
                "$ref": "#/components/schemas/ThermalModesConfig"
              }
            ]
          }
        },
        "required": [
          "pwm_controller",
          "direction_controller",
          "thermal_modes"
        ]
      },
      "PwmChannelConfig": {
        "description": "PWM channel configuration",
        "type": "object",
        "properties": {
          "address": {
            "description": "PCA9685 I2C address",
            "type": "integer",
            "format": "uint8",
            "minimum": 0,
            "maximum": 255
          },
          "channel": {
            "description": "PWM channel number (0-15)",
            "type": "integer",
            "format": "uint8",
            "minimum": 0,
            "maximum": 255
          }
        },
        "required": [
          "address",
          "channel"
        ]
      },
      "DirectionControllerConfig": {
        "description": "Direction controller configuration for H-Bridge control",
        "type": "object",
        "properties": {
          "address": {
            "description": "CAT9555 I2C address",
            "type": "integer",
            "format": "uint8",
            "minimum": 0,
            "maximum": 255
          },
          "gpio_pins": {
            "description": "GPIO pins mapping for H-Bridge control",
            "allOf": [
              {
                "$ref": "#/components/schemas/HBridgeGpioPins"
              }
            ]
          }
        },
        "required": [
          "address",
          "gpio_pins"
        ]
      },
      "HBridgeGpioPins": {
        "description": "H-Bridge GPIO pins configuration",
        "type": "object",
        "properties": {
          "h_bridge_in1": {
            "description": "GPIO pin for H-Bridge IN1 (direction bit 1)",
            "type": "integer",
            "format": "uint8",
            "minimum": 0,
            "maximum": 255
          },
          "h_bridge_in2": {
            "description": "GPIO pin for H-Bridge IN2 (direction bit 2)",
            "type": "integer",
            "format": "uint8",
            "minimum": 0,
            "maximum": 255
          },
          "h_bridge_enable": {
            "description": "GPIO pin for H-Bridge enable",
            "type": "integer",
            "format": "uint8",
            "minimum": 0,
            "maximum": 255
          }
        },
        "required": [
          "h_bridge_in1",
          "h_bridge_in2",
          "h_bridge_enable"
        ]
      },
      "ThermalModesConfig": {
        "description": "Thermal modes configuration",
        "type": "object",
        "properties": {
          "heating_tec": {
            "description": "Heating via TEC (Peltier) mode",
            "allOf": [
              {
                "$ref": "#/components/schemas/ThermalModeConfig"
              }
            ]
          },
          "cooling_tec": {
            "description": "Cooling via TEC (Peltier) mode",
            "allOf": [
              {
                "$ref": "#/components/schemas/ThermalModeConfig"
              }
            ]
          },
          "heating_resistive": {
            "description": "Heating via resistive element mode",
            "allOf": [
              {
                "$ref": "#/components/schemas/ThermalModeConfig"
              }
            ]
          }
        },
        "required": [
          "heating_tec",
          "cooling_tec",
          "heating_resistive"
        ]
      },
      "ThermalModeConfig": {
        "description": "Individual thermal mode configuration",
        "type": "object",
        "properties": {
          "description": {
            "description": "Human-readable description",
            "type": "string"
          },
          "h_bridge_direction": {
            "description": "H-Bridge direction (\"forward\" or \"reverse\")",
            "allOf": [
              {
                "$ref": "#/components/schemas/HBridgeDirection"
              }
            ]
          },
          "power_range": {
            "description": "Power range as string (e.g., \"0-80%\")",
            "type": "string"
          },
          "max_power_percent": {
            "description": "Maximum power percentage for this mode",
            "type": "number",
            "format": "float",
            "default": 100.0
          }
        },
        "required": [
          "description",
          "h_bridge_direction",
          "power_range"
        ]
      },
      "HBridgeDirection": {
        "description": "H-Bridge direction",
        "oneOf": [
          {
            "description": "Forward direction (IN1=HIGH, IN2=LOW)",
            "type": "string",
            "enum": [
              "forward"
            ]
          },
          {
            "description": "Reverse direction (IN1=LOW, IN2=HIGH)",
            "type": "string",
            "enum": [
              "reverse"
            ]
          }
        ]
      },
      "TemperatureConversionConfig": {
        "description": "Temperature conversion configuration",
        "type": "object",
        "properties": {
          "formula": {
            "description": "Conversion formula (polynomial or lookup table)",
            "type": "string"
          },
          "adc_resolution": {
            "description": "ADC resolution in bits",
            "type": "integer",
            "format": "uint8",
            "minimum": 0,
            "maximum": 255
          },
          "voltage_reference": {
            "description": "Voltage reference in volts",
            "type": "number",
            "format": "float"
          },
          "conversion_type": {
            "description": "Conversion type",
            "default": "polynomial",
            "allOf": [
              {
                "$ref": "#/components/schemas/ConversionType"
              }
            ]
          }
        },
        "required": [
          "formula",
          "adc_resolution",
          "voltage_reference"
        ]
      },
      "ConversionType": {
        "description": "Temperature conversion type",
        "oneOf": [
          {
            "description": "Polynomial conversion",
            "type": "string",
            "enum": [
              "polynomial"
            ]
          },
          {
            "description": "Linear conversion",
            "type": "string",
            "enum": [
              "linear"
            ]
          },
          {
            "description": "Lookup table",
            "type": "string",
            "enum": [
              "lookup_table"
            ]
          },
          {
            "description": "NTC thermistor conversion using mathematical formula",
            "type": "string",
            "enum": [
              "ntc_thermistor"
            ]
          }
        ]
      },
      "PidParameters": {
        "description": "PID controller parameters",
        "type": "object",
        "properties": {
          "kp": {
            "description": "Proportional gain",
            "type": "number",
            "format": "float"
          },
          "ki": {
            "description": "Integral gain",
            "type": "number",
            "format": "float"
          },
          "kd": {
            "description": "Derivative gain",
            "type": "number",
            "format": "float"
          },
          "setpoint": {
            "description": "Target temperature setpoint in Kelvin",
            "type": "number",
            "format": "float"
          },
          "output_min": {
            "description": "Minimum output value",
            "type": "number",
            "format": "float"
          },
          "output_max": {
            "description": "Maximum output value",
            "type": "number",
            "format": "float"
          },
          "integral_max": {
            "description": "Maximum integral value (anti-windup)",
            "type": "number",
            "format": "float"
          },
          "settings": {
            "description": "PID controller settings",
            "default": {
              "derivative_on_measurement": false,
              "integral_clamping": true,
              "output_rate_limit": null
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/PidSettings"
              }
            ]
          }
        },
        "required": [
          "kp",
          "ki",
          "kd",
          "setpoint",
          "output_min",
          "output_max",
          "integral_max"
        ]
      },
      "PidSettings": {
        "description": "PID controller settings",
        "type": "object",
        "properties": {
          "derivative_on_measurement": {
            "description": "Derivative on measurement (instead of error)",
            "type": "boolean",
            "default": false
          },
          "integral_clamping": {
            "description": "Integral clamping enabled",
            "type": "boolean",
            "default": true
          },
          "output_rate_limit": {
            "description": "Output rate limiting",
            "type": "number",
            "format": "float",
            "default": null,
            "nullable": true
          }
        }
      },
      "ControlParameters": {
        "description": "Control system parameters",
        "type": "object",
        "properties": {
          "sampling_frequency_hz": {
            "description": "Sampling frequency in Hz",
            "type": "number",
            "format": "float"
          },
          "pwm_frequency_hz": {
            "description": "PWM frequency in Hz",
            "type": "number",
            "format": "float"
          },
          "settings": {
            "description": "Control loop settings",
            "default": {
              "adaptive_control": false,
              "deadband_k": 0.10000000149011612,
              "min_control_action": 0.10000000149011612
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ControlSettings"
              }
            ]
          }
        },
        "required": [
          "sampling_frequency_hz",
          "pwm_frequency_hz"
        ]
      },
      "ControlSettings": {
        "description": "Control loop settings",
        "type": "object",
        "properties": {
          "adaptive_control": {
            "description": "Enable adaptive control",
            "type": "boolean",
            "default": false
          },
          "deadband_k": {
            "description": "Deadband around setpoint",
            "type": "number",
            "format": "float",
            "default": 0.0
          },
          "min_control_action": {
            "description": "Minimum control action",
            "type": "number",
            "format": "float",
            "default": 0.0
          }
        }
      },
      "SafetyLimits": {
        "description": "Safety limits and protections",
        "type": "object",
        "properties": {
          "min_temperature_k": {
            "description": "Minimum allowed temperature in Kelvin",
            "type": "number",
            "format": "float"
          },
          "max_temperature_k": {
            "description": "Maximum allowed temperature in Kelvin",
            "type": "number",
            "format": "float"
          },
          "max_heating_duty": {
            "description": "Maximum heating duty cycle percentage",
            "type": "number",
            "format": "float"
          },
          "max_cooling_duty": {
            "description": "Maximum cooling duty cycle percentage",
            "type": "number",
            "format": "float"
          },
          "emergency_settings": {
            "description": "Emergency shutdown settings",
            "default": {
              "enabled": true,
              "emergency_temp_k": 373.1499938964844,
              "response_timeout_s": 5.0
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/EmergencySettings"
              }
            ]
          }
        },
        "required": [
          "min_temperature_k",
          "max_temperature_k",
          "max_heating_duty",
          "max_cooling_duty"
        ]
      },
      "EmergencySettings": {
        "description": "Emergency settings",
        "type": "object",
        "properties": {
          "enabled": {
            "description": "Enable emergency shutdown",
            "type": "boolean",
            "default": true
          },
          "emergency_temp_k": {
            "description": "Temperature threshold for emergency shutdown",
            "type": "number",
            "format": "float",
            "default": 373.1499938964844
          },
          "response_timeout_s": {
            "description": "Timeout for emergency response in seconds",
            "type": "number",
            "format": "float",
            "default": 5.0
          }
        }
      },
      "GlobalThermalSettings": {
        "description": "Global thermal regulation settings",
        "type": "object",
        "properties": {
          "global_sampling_rate_hz": {
            "description": "Global sampling rate for all regulators",
            "type": "number",
            "format": "float",
            "default": 10.0
          },
          "max_concurrent_regulators": {
            "description": "Maximum number of concurrent regulators",
            "type": "integer",
            "format": "uint8",
            "minimum": 0,
            "maximum": 255,
            "default": 32
          },
          "resource_sharing": {
            "description": "Resource sharing settings",
            "default": {
              "i2c_arbitration_timeout_ms": 100,
              "max_operation_queue_size": 100,
              "priority_scheduling": false
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ResourceSharingSettings"
              }
            ]
          },
          "monitoring": {
            "description": "Logging and monitoring settings",
            "default": {
              "enable_performance_monitoring": true,
              "metrics_interval_s": 1.0,
              "enable_thermal_history": false,
              "history_buffer_size": 1000
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/MonitoringSettings"
              }
            ]
          }
        }
      },
      "ResourceSharingSettings": {
        "description": "Resource sharing settings",
        "type": "object",
        "properties": {
          "i2c_arbitration_timeout_ms": {
            "description": "I2C bus arbitration timeout in milliseconds",
            "type": "integer",
            "format": "uint32",
            "minimum": 0,
            "default": 100
          },
          "max_operation_queue_size": {
            "description": "Maximum queue size for pending operations",
            "type": "integer",
            "format": "uint",
            "minimum": 0,
            "default": 100
          },
          "priority_scheduling": {
            "description": "Enable priority-based scheduling",
            "type": "boolean",
            "default": false
          }
        }
      },
      "MonitoringSettings": {
        "description": "Monitoring settings",
        "type": "object",
        "properties": {
          "enable_performance_monitoring": {
            "description": "Enable performance monitoring",
            "type": "boolean",
            "default": true
          },
          "metrics_interval_s": {
            "description": "Metrics collection interval in seconds",
            "type": "number",
            "format": "float",
            "default": 1.0
          },
          "enable_thermal_history": {
            "description": "Enable thermal history logging",
            "type": "boolean",
            "default": false
          },
          "history_buffer_size": {
            "description": "History buffer size",
            "type": "integer",
            "format": "uint",
            "minimum": 0,
            "default": 1000
          }
        }
      },
      "GenerixConfig": {
        "description": "Configuration for a Generix-compatible OAuth2/OIDC provider.\n\nThis struct contains all parameters required to interact with the provider for authentication and token validation.\nIt is typically loaded from a YAML file and injected into Rocket state for use throughout the application.",
        "type": "object",
        "properties": {
          "provider": {
            "description": "Name of the OAuth2 provider (e.g., \"generix\").",
            "type": "string"
          },
          "api_base_url": {
            "description": "Base URL for the provider's API.",
            "type": "string"
          },
          "authority": {
            "description": "Authority URL for the OAuth2 provider, used for token validation.",
            "type": "string"
          },
          "client_id": {
            "description": "OAuth2 client ID registered with the provider.",
            "type": "string"
          },
          "scope": {
            "description": "Space-separated list of OAuth2 scopes to request.",
            "type": "string"
          },
          "redirect_uri": {
            "description": "Redirect URI registered for OAuth2 callbacks.",
            "type": "string"
          },
          "audience": {
            "description": "Expected audience claim in JWTs.",
            "type": "string"
          },
          "token_issuer": {
            "description": "Expected issuer claim in JWTs.",
            "type": "string"
          },
          "jwks_endpoint": {
            "description": "URL to the provider's JWKS (JSON Web Key Set) endpoint.",
            "type": "string"
          },
          "domain": {
            "description": "Domain name for the provider or application.",
            "type": "string"
          },
          "issuer": {
            "description": "Issuer for the OpenID Connect discovery document.",
            "type": "string"
          }
        },
        "required": [
          "provider",
          "api_base_url",
          "authority",
          "client_id",
          "scope",
          "redirect_uri",
          "audience",
          "token_issuer",
          "jwks_endpoint",
          "domain",
          "issuer"
        ]
      },
      "ProcessingGraphStatistics": {
        "title": "Processing Graph Statistics",
        "description": "Overall performance statistics for the entire processing graph",
        "type": "object",
        "properties": {
          "node_statistics": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/NodeStatistics"
            }
          },
          "total_executions": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "total_graph_processing_time": {
            "title": "Duration in nanoseconds",
            "type": "integer",
            "format": "int64"
          },
          "average_graph_processing_time": {
            "title": "Duration in nanoseconds",
            "type": "integer",
            "format": "int64"
          },
          "fastest_graph_execution": {
            "title": "Duration in nanoseconds",
            "type": "integer",
            "format": "int64"
          },
          "worst_graph_execution": {
            "title": "Duration in nanoseconds",
            "type": "integer",
            "format": "int64"
          },
          "active_nodes": {
            "type": "integer",
            "format": "uint",
            "minimum": 0
          },
          "connections_count": {
            "type": "integer",
            "format": "uint",
            "minimum": 0
          }
        },
        "required": [
          "node_statistics",
          "total_executions",
          "total_graph_processing_time",
          "average_graph_processing_time",
          "fastest_graph_execution",
          "worst_graph_execution",
          "active_nodes",
          "connections_count"
        ]
      },
      "NodeStatistics": {
        "type": "object",
        "properties": {
          "node_id": {
            "type": "string"
          },
          "node_type": {
            "type": "string"
          },
          "frames_processed": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "total_processing_time": {
            "title": "Duration in nanoseconds",
            "type": "integer",
            "format": "int64"
          },
          "average_processing_time": {
            "title": "Duration in nanoseconds",
            "type": "integer",
            "format": "int64"
          },
          "fastest_processing_time": {
            "title": "Duration in nanoseconds",
            "type": "integer",
            "format": "int64"
          },
          "worst_processing_time": {
            "title": "Duration in nanoseconds",
            "type": "integer",
            "format": "int64"
          }
        },
        "required": [
          "node_id",
          "node_type",
          "frames_processed",
          "total_processing_time",
          "average_processing_time",
          "fastest_processing_time",
          "worst_processing_time"
        ]
      },
      "SerializableProcessingGraph": {
        "title": "Serializable Processing Graph",
        "description": "Complete serializable representation of a processing graph with nodes, connections and statistics",
        "type": "object",
        "properties": {
          "nodes": {
            "description": "List of processing nodes in the graph",
            "type": "array"
          },
          "connections": {
            "description": "List of connections between nodes",
            "type": "array"
          },
          "execution_order": {
            "description": "Topological execution order of nodes",
            "type": "array"
          },
          "input_node": {
            "description": "ID of the input node",
            "type": "string"
          },
          "output_nodes": {
            "description": "List of output node IDs",
            "type": "array"
          },
          "is_valid": {
            "description": "Whether the graph is valid",
            "type": "boolean"
          },
          "validation_errors": {
            "description": "List of validation errors if any",
            "type": "array"
          }
        },
        "required": [
          "nodes",
          "connections",
          "execution_order"
        ]
      },
      "SystemStats": {
        "description": "Comprehensive system statistics for the current process",
        "type": "object",
        "properties": {
          "cpu_usage_percent": {
            "description": "CPU usage percentage (0.0 to 100.0)",
            "type": "number",
            "format": "float"
          },
          "memory_usage_mb": {
            "description": "Physical memory usage in megabytes",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "virtual_memory_mb": {
            "description": "Virtual memory usage in megabytes",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "thread_count": {
            "description": "Number of threads in the current process",
            "type": "integer",
            "format": "uint",
            "minimum": 0
          },
          "total_cpu_cores": {
            "description": "Total number of CPU cores in the system",
            "type": "integer",
            "format": "uint",
            "minimum": 0
          },
          "available_memory_mb": {
            "description": "Available system memory in megabytes",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "uptime_seconds": {
            "description": "System uptime in seconds",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "process_uptime_seconds": {
            "description": "Process uptime in seconds",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "timestamp": {
            "description": "Timestamp when these statistics were collected",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          }
        },
        "required": [
          "cpu_usage_percent",
          "memory_usage_mb",
          "virtual_memory_mb",
          "thread_count",
          "total_cpu_cores",
          "available_memory_mb",
          "uptime_seconds",
          "process_uptime_seconds",
          "timestamp"
        ]
      },
      "SystemHealthReport": {
        "description": "Combined system and processing health report",
        "type": "object",
        "properties": {
          "system_stats": {
            "description": "Current system resource statistics",
            "allOf": [
              {
                "$ref": "#/components/schemas/SystemStats"
              }
            ]
          },
          "processing_summary": {
            "description": "Processing pipeline performance summary",
            "anyOf": [
              {
                "$ref": "#/components/schemas/ProcessingPerformanceSummary"
              },
              {
                "nullable": true,
                "enum": [
                  null
                ]
              }
            ]
          },
          "health_status": {
            "description": "Overall system health assessment",
            "allOf": [
              {
                "$ref": "#/components/schemas/HealthStatus"
              }
            ]
          },
          "recommendations": {
            "description": "Recommendations for system optimization",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "system_stats",
          "health_status",
          "recommendations"
        ]
      },
      "ProcessingPerformanceSummary": {
        "description": "Processing performance summary for health monitoring",
        "type": "object",
        "properties": {
          "avg_execution_time_ms": {
            "description": "Average processing time per frame in milliseconds",
            "type": "number",
            "format": "double"
          },
          "efficiency_percentage": {
            "description": "Processing efficiency percentage (0-100)",
            "type": "number",
            "format": "double"
          },
          "active_nodes": {
            "description": "Number of active processing nodes",
            "type": "integer",
            "format": "uint",
            "minimum": 0
          },
          "total_executions": {
            "description": "Total number of completed executions",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "slowest_node": {
            "description": "ID of the slowest node (bottleneck)",
            "type": "string",
            "nullable": true
          }
        },
        "required": [
          "avg_execution_time_ms",
          "efficiency_percentage",
          "active_nodes",
          "total_executions"
        ]
      },
      "HealthStatus": {
        "description": "System health status assessment",
        "oneOf": [
          {
            "description": "All systems operating normally",
            "type": "string",
            "enum": [
              "Healthy"
            ]
          },
          {
            "description": "Minor performance issues detected",
            "type": "object",
            "properties": {
              "Warning": {
                "type": "object",
                "properties": {
                  "issues": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "required": [
                  "issues"
                ]
              }
            },
            "required": [
              "Warning"
            ],
            "additionalProperties": false
          },
          {
            "description": "Significant performance degradation",
            "type": "object",
            "properties": {
              "Critical": {
                "type": "object",
                "properties": {
                  "issues": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "required": [
                  "issues"
                ]
              }
            },
            "required": [
              "Critical"
            ],
            "additionalProperties": false
          }
        ]
      },
      "MeasurementData": {
        "description": "Core action data passed to drivers",
        "type": "object",
        "properties": {
          "concentration_ppm": {
            "description": "Current concentration value in ppm",
            "type": "number",
            "format": "double"
          },
          "source_node_id": {
            "description": "Source node ID that generated this data",
            "type": "string"
          },
          "peak_amplitude": {
            "description": "Peak amplitude value (0.0-1.0)",
            "type": "number",
            "format": "float"
          },
          "peak_frequency": {
            "description": "Peak frequency in Hz",
            "type": "number",
            "format": "float"
          },
          "timestamp": {
            "description": "Timestamp of the measurement",
            "allOf": [
              {
                "$ref": "#/components/schemas/SystemTime"
              }
            ]
          },
          "metadata": {
            "description": "Additional metadata for the action",
            "type": "object",
            "additionalProperties": true
          }
        },
        "required": [
          "concentration_ppm",
          "source_node_id",
          "peak_amplitude",
          "peak_frequency",
          "timestamp",
          "metadata"
        ]
      },
      "SystemTime": {
        "type": "object",
        "properties": {
          "secs_since_epoch": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "nanos_since_epoch": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          }
        },
        "required": [
          "secs_since_epoch",
          "nanos_since_epoch"
        ]
      },
      "ActionNodeInfo": {
        "description": "Response structure for action node list",
        "type": "object",
        "properties": {
          "id": {
            "description": "Node ID",
            "type": "string"
          },
          "node_type": {
            "description": "Node type",
            "type": "string"
          },
          "has_driver": {
            "description": "Whether the node has a configured driver",
            "type": "boolean"
          },
          "monitored_nodes_count": {
            "description": "Number of monitored computing nodes",
            "type": "integer",
            "format": "uint",
            "minimum": 0
          },
          "buffer_size": {
            "description": "Current buffer size",
            "type": "integer",
            "format": "uint",
            "minimum": 0
          },
          "buffer_capacity": {
            "description": "Buffer capacity",
            "type": "integer",
            "format": "uint",
            "minimum": 0
          }
        },
        "required": [
          "id",
          "node_type",
          "has_driver",
          "monitored_nodes_count",
          "buffer_size",
          "buffer_capacity"
        ]
      },
      "TestResponse": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          },
          "token": {
            "type": "string"
          },
          "user": {
            "type": "string"
          },
          "message": {
            "type": "string",
            "nullable": true
          }
        },
        "required": [
          "description",
          "token",
          "user"
        ]
      },
      "TestData": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string"
          }
        },
        "required": [
          "message"
        ]
      },
      "DisplayUpdateData": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          },
          "concentration_ppm": {
            "type": "number",
            "format": "double",
            "default": null,
            "nullable": true
          },
          "source_node_id": {
            "type": "string",
            "default": null,
            "nullable": true
          },
          "peak_amplitude": {
            "type": "number",
            "format": "float",
            "default": null,
            "nullable": true
          },
          "peak_frequency": {
            "type": "number",
            "format": "float",
            "default": null,
            "nullable": true
          },
          "timestamp": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "metadata": {
            "type": "object",
            "default": null,
            "additionalProperties": true,
            "nullable": true
          },
          "retry_attempt": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0,
            "default": null,
            "nullable": true
          },
          "alert_type": {
            "type": "string",
            "default": null,
            "nullable": true
          },
          "severity": {
            "type": "string",
            "default": null,
            "nullable": true
          },
          "message": {
            "type": "string",
            "default": null,
            "nullable": true
          },
          "data": {
            "type": "object",
            "default": null,
            "additionalProperties": true,
            "nullable": true
          }
        },
        "required": [
          "type",
          "timestamp"
        ]
      },
      "ComputingResponse": {
        "type": "object",
        "properties": {
          "peak_results": {
            "description": "Peak results from multiple nodes, keyed by node ID",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/PeakResultResponse"
            }
          },
          "peak_frequency": {
            "description": "Legacy fields for backward compatibility",
            "type": "number",
            "format": "float",
            "nullable": true
          },
          "peak_amplitude": {
            "type": "number",
            "format": "float",
            "nullable": true
          },
          "concentration_ppm": {
            "type": "number",
            "format": "float",
            "nullable": true
          },
          "polynomial_coefficients": {
            "type": "array",
            "items": {
              "type": "number",
              "format": "double"
            },
            "minItems": 5,
            "maxItems": 5
          },
          "active_node_ids": {
            "description": "Node IDs that have recent data (within last 30 seconds)",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "latest_result": {
            "description": "Most recent result across all nodes",
            "anyOf": [
              {
                "$ref": "#/components/schemas/PeakResultResponse"
              },
              {
                "nullable": true,
                "enum": [
                  null
                ]
              }
            ]
          }
        },
        "required": [
          "peak_results",
          "polynomial_coefficients",
          "active_node_ids"
        ]
      },
      "PeakResultResponse": {
        "type": "object",
        "properties": {
          "frequency": {
            "type": "number",
            "format": "float"
          },
          "amplitude": {
            "type": "number",
            "format": "float"
          },
          "concentration_ppm": {
            "type": "number",
            "format": "float",
            "nullable": true
          },
          "timestamp": {
            "$ref": "#/components/schemas/SystemTime"
          }
        },
        "required": [
          "frequency",
          "amplitude",
          "timestamp"
        ]
      },
      "PaginatedThermalResponse": {
        "description": "Paginated thermal data response",
        "type": "object",
        "properties": {
          "data": {
            "description": "Filtered thermal regulation data",
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ThermalDataPoint"
              }
            }
          },
          "pagination": {
            "description": "Pagination metadata",
            "allOf": [
              {
                "$ref": "#/components/schemas/PaginationInfo"
              }
            ]
          },
          "filters": {
            "description": "Applied filters summary",
            "allOf": [
              {
                "$ref": "#/components/schemas/FilterSummary"
              }
            ]
          }
        },
        "required": [
          "data",
          "pagination",
          "filters"
        ]
      },
      "ThermalDataPoint": {
        "description": "Single data point in thermal regulation history",
        "type": "object",
        "properties": {
          "timestamp": {
            "description": "Timestamp in Unix seconds",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "temperature_celsius": {
            "description": "Temperature reading in degrees Celsius",
            "type": "number",
            "format": "double"
          },
          "control_output_percent": {
            "description": "Control output percentage (-100.0 to +100.0)",
            "type": "number",
            "format": "double"
          },
          "setpoint_celsius": {
            "description": "PID setpoint temperature in degrees Celsius",
            "type": "number",
            "format": "double"
          },
          "pid_components": {
            "description": "Individual PID components for debugging",
            "allOf": [
              {
                "$ref": "#/components/schemas/PidComponents"
              }
            ]
          }
        },
        "required": [
          "timestamp",
          "temperature_celsius",
          "control_output_percent",
          "setpoint_celsius",
          "pid_components"
        ]
      },
      "PidComponents": {
        "description": "PID controller components for analysis",
        "type": "object",
        "properties": {
          "proportional": {
            "description": "Proportional term value",
            "type": "number",
            "format": "double"
          },
          "integral": {
            "description": "Integral term value",
            "type": "number",
            "format": "double"
          },
          "derivative": {
            "description": "Derivative term value",
            "type": "number",
            "format": "double"
          },
          "error": {
            "description": "Error value (setpoint - process_variable)",
            "type": "number",
            "format": "double"
          }
        },
        "required": [
          "proportional",
          "integral",
          "derivative",
          "error"
        ]
      },
      "PaginationInfo": {
        "description": "Pagination information for thermal data responses",
        "type": "object",
        "properties": {
          "page": {
            "description": "Current page number (1-indexed)",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "limit": {
            "description": "Number of items per page",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "total_items": {
            "description": "Total number of items across all pages",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "total_pages": {
            "description": "Total number of pages available",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "has_next": {
            "description": "Whether there is a next page available",
            "type": "boolean"
          },
          "has_previous": {
            "description": "Whether there is a previous page available",
            "type": "boolean"
          }
        },
        "required": [
          "page",
          "limit",
          "total_items",
          "total_pages",
          "has_next",
          "has_previous"
        ]
      },
      "FilterSummary": {
        "description": "Summary of applied filters",
        "type": "object",
        "properties": {
          "step_seconds": {
            "description": "Step size in seconds between data points",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "included_regulators": {
            "description": "List of regulator IDs included in the response",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "from_timestamp": {
            "description": "Start timestamp (Unix seconds) for data range",
            "type": "integer",
            "format": "uint64",
            "minimum": 0,
            "nullable": true
          },
          "to_timestamp": {
            "description": "End timestamp (Unix seconds) for data range",
            "type": "integer",
            "format": "uint64",
            "minimum": 0,
            "nullable": true
          }
        },
        "required": [
          "step_seconds",
          "included_regulators"
        ]
      },
      "CurrentTemperatureInfo": {
        "description": "Current temperature information for a thermal regulator",
        "type": "object",
        "properties": {
          "temperature_celsius": {
            "description": "Current temperature reading in degrees Celsius",
            "type": "number",
            "format": "double"
          },
          "timestamp": {
            "description": "Timestamp of the temperature reading (Unix seconds)",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "setpoint_celsius": {
            "description": "Current setpoint temperature in degrees Celsius",
            "type": "number",
            "format": "double"
          },
          "control_output_percent": {
            "description": "Current output power of the regulator",
            "type": "number",
            "format": "double"
          },
          "status": {
            "description": "Current status of the regulator",
            "type": "string"
          }
        },
        "required": [
          "temperature_celsius",
          "timestamp",
          "setpoint_celsius",
          "control_output_percent",
          "status"
        ]
      },
      "StreamStats": {
        "description": "Statistics about the audio stream",
        "type": "object",
        "properties": {
          "total_frames": {
            "description": "Total number of frames processed",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "dropped_frames": {
            "description": "Total number of dropped frames",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "active_subscribers": {
            "description": "Number of active subscribers",
            "type": "integer",
            "format": "uint",
            "minimum": 0
          },
          "fps": {
            "description": "Average frames per second",
            "type": "number",
            "format": "double"
          },
          "last_update": {
            "description": "Last update timestamp",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "frames_since_last_update": {
            "description": "Frames processed since last FPS calculation",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "sample_rate": {
            "description": "Sample rate of the audio stream in Hz",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "dual_channel": {
            "description": "Whether the stream has dual channels (true) or is mono (false)",
            "type": "boolean"
          }
        },
        "required": [
          "total_frames",
          "dropped_frames",
          "active_subscribers",
          "fps",
          "last_update",
          "frames_since_last_update",
          "sample_rate",
          "dual_channel"
        ]
      },
      "AudioFrameResponse": {
        "description": "Response structure for audio frame data",
        "type": "object",
        "properties": {
          "channel_a": {
            "description": "Channel A audio data",
            "type": "array",
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "channel_b": {
            "description": "Channel B audio data",
            "type": "array",
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "sample_rate": {
            "description": "Sample rate of the audio data",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "timestamp": {
            "description": "Timestamp when the frame was captured",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "frame_number": {
            "description": "Sequential frame number",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "duration_ms": {
            "description": "Duration of this frame in milliseconds",
            "type": "number",
            "format": "double"
          }
        },
        "required": [
          "channel_a",
          "channel_b",
          "sample_rate",
          "timestamp",
          "frame_number",
          "duration_ms"
        ]
      },
      "StreamingNodeInfo": {
        "description": "Response structure for listing available streaming nodes",
        "type": "object",
        "properties": {
          "id": {
            "description": "Node string ID from configuration (preferred for permanent links)",
            "type": "string"
          },
          "uuid": {
            "description": "Node UUID (for backward compatibility and internal operations)",
            "type": "string"
          },
          "name": {
            "description": "Human-readable node name (if available)",
            "type": "string",
            "nullable": true
          },
          "is_active": {
            "description": "Whether the node is currently streaming",
            "type": "boolean"
          },
          "subscriber_count": {
            "description": "Current subscriber count for this node's stream",
            "type": "integer",
            "format": "uint",
            "minimum": 0
          }
        },
        "required": [
          "id",
          "uuid",
          "is_active",
          "subscriber_count"
        ]
      },
      "AudioStreamInfo": {
        "description": "Response structure for available audio stream information",
        "type": "object",
        "properties": {
          "id": {
            "description": "Stream identifier (e.g., \"realtime_source\", \"streaming_output\")",
            "type": "string"
          },
          "stream_url": {
            "description": "Stream URL endpoint for consuming audio data",
            "type": "string"
          },
          "stats_url": {
            "description": "Statistics URL endpoint for stream metrics",
            "type": "string"
          }
        },
        "required": [
          "id",
          "stream_url",
          "stats_url"
        ]
      }
    },
    "securitySchemes": {
      "BearerAuth": {
        "description": "Requires a valid JWT Bearer token for authentication. The token must be provided in the Authorization header as 'Bearer <token>'. Supports both HMAC (HS256) and RSA (RS256) signed tokens.",
        "type": "http",
        "scheme": "bearer",
        "bearerFormat": "JWT",
        "x-bearer-format": "JWT",
        "x-description": "JWT tokens are issued by the /token endpoint after successful authentication"
      }
    }
  }
}
