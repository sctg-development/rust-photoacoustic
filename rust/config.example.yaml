# Photoacoustic Water Vapor Analyzer Configuration Example
# --------------------------------------------------------
# This YAML file configures the rust-photoacoustic application.
# YAML is a text based structured file format @see https://en.wikipedia.org/wiki/YAML
# It must pass validation against config.schema.json (see docs for schema details).
# To view the schema, run: `rust-photoacoustic ---show-config-schema`
#
# =========================
# HOW TO GENERATE SECRETS AND CERTIFICATES
# =========================
#
# --- Generate RSA keypair for RS256 JWT signing ---
# POSIX (Linux/macOS):
#   openssl genpkey -algorithm RSA -out private.key -pkeyopt rsa_keygen_bits:2048
#   openssl rsa -pubout -in private.key -out pub.key
#   cat private.key | base64 -w0 > private.key.b64
#   cat pub.key | base64 -w0 > pub.key.b64
# Windows (using Git Bash or WSL):
#   Same as above, or use OpenSSL for Windows (https://slproweb.com/products/Win32OpenSSL.html)
#   Use 'base64 -w0' or 'certutil -encode' (then remove header/footer lines)
#
# --- Generate a PEM certificate for HTTPS (self-signed) ---
# POSIX:
#   openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes -subj "/CN=localhost"
#   base64 -w0 cert.pem > cert.txt
#   base64 -w0 key.pem > key.txt
# Windows:
#   Use OpenSSL for Windows as above, or use PowerShell:
#   New-SelfSignedCertificate -DnsName "localhost" -CertStoreLocation "cert:\LocalMachine\My"
#   # Export as PEM using certmgr or OpenSSL
#
# --- Generate a password hash for a user ---
# POSIX:
#   openssl passwd -5 mypassword | base64 -w0
# Windows:
#   Use Git Bash or WSL for the above, or use Python:
#   python -c "import crypt,base64; print(base64.b64encode(crypt.crypt('mypassword', crypt.mksalt(crypt.METHOD_SHA512)).encode()).decode())"
#
# --- Validate this YAML against the JSON schema ---
# 1. Convert YAML to JSON (e.g. https://www.json2yaml.com/ or https://yaml-online-parser.appspot.com/)
# 2. Use an online JSON schema validator (e.g. https://www.jsonschemavalidator.net/)
#    - Upload your converted JSON
#    - Upload config.schema.json from the repository
#    - Validate and check for errors
#
# =========================
# Visualization server settings
# =========================
visualization:
  # TCP port for the web server (default: 8080)
  port: 8080
  # IP address to bind the server (use 0.0.0.0 for all interfaces)
  address: 127.0.0.1
  # Server name/version string (for HTTP headers and logs)
  name: LaserSmartApiServer/0.1.0

  # Secret key for signing session cookies (keep this private!)
  # Generate securely: `openssl rand -base64 32`
  session_secret: 6wcVSUhxt1+YPEondChFXtesCL1boh57gqHv2gnEH7U=

  # SSL certificate and key (Base64-encoded PEM, optional for HTTPS)
  # To enable HTTPS, provide both cert and key fields below.
  # Generate and encode with:
  #   cat rust-photoacoustic.local.pem | base64 -w0 > cert.txt
  #   cat rust-photoacoustic.local.key | base64 -w0 > key.txt
  cert: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZ3d0RRWUpLb1pJaHZjTkFRRUJCUUFEU3dBd1NBSkJBS3FZcWszcVAwTkQrelJDeTdIMjZrUHVuQmpMTEpFNQp4Z0p5VzBQZm8wb3pUelV0Tk1DZFRHZzB5a3hFSjA5NXVEUXpGYWZxME5FcTBWeG40MjJZWXRzQ0F3RUFBUT09Ci0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLQo=
  key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUJWUUlCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQVQ4d2dnRTdBZ0VBQWtFQXFwaXFUZW8vUTBQN05FTEwKc2ZicVErNmNHTXNza1RuR0FuSmJROStqU2pOUE5TMDB3SjFNYURUS1RFUW5UM200TkRNVnArclEwU3JSWEdmagpiWmhpMndJREFRQUJBa0JzVWlXSTlaMFh5L21jZEhFOFhnamYrNGs0SVFINmNKR3ZDZ2V6TURSUnJ2cHRjM0YwCnVETEN5K21kQnBPOCs2b2FvcE9wN3hIa053OU42U2FPMGZhWkFpRUE0cjArbEpOQ3FZaGdSdTNIb2xKT0dRMkUKcnVTdHUrZStRM2pxVnN3U29zVUNJUURBbktLalFJdEZONnpxdHpPK1lnanNudFNOeG1iKzdlSnRsY2JLa0FMSgpId0loQUlRL1h3M25xbjBaaHhZM3dEWGtEWnM5TUVPV0srTXFjdVlGMDZEV25KUUZBaUJUb3pDVVJ6Q3lxOHh3ClY0RW1pSmRyZUVUQUU0a2g1ZFpPMDV6dzFMd0E3UUloQU1maU5ULzVXYzY1YzhGNWR6MFRvQjQ1aTVZYVRNYnoKbkNwQWpGQm5kN0E0Ci0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K

  # JWT authentication secrets:
  # HMAC secret for HS256 JWT signing (used for API authentication)
  hmac_secret: my-super-secret-jwt-key-for-photoacoustic-app

  # RSA keys for RS256 JWT signing (Base64-encoded PEM, used for API authentication)
  # Generate with the `rs256keygen` utility or OpenSSL.
  # These are optional unless you want RS256 support.
  rs256_private_key: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUdyQWdFQUFpRUFyd0FZcXAvdGVvaUE4N2FWQStJTjQ1U1RvMTdMUVZPbGRUT3FJeHhQeElNQ0F3RUFBUUlnCldRVlpodUpYOGE4aXVkYzFNb1o1dldYcmxwdFlEUTQ3RXUwa2pNVVA2T0VDRVFEUjEyN0RsZWNKNU80V3B2VEcKdnQ1YkFoRUExWDZ4ZVVzUXpISkZTYlV4eXZEYStRSVJBS2Z1b05ZbHdTQko5Y0JySExseFJzRUNFUURCcTBOZApqNTMyaUxhWURablV5amNwQWhCSG9CU1JSTS9ESVA5dWE1MDhYMEtOCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
  rs256_public_key: LS0tLS1CRUdJTiBSU0EgUFVCTElDIEtFWS0tLS0tCk1DZ0NJUUN2QUJpcW4rMTZpSUR6dHBVRDRnM2psSk9qWHN0QlU2VjFNNm9qSEUvRWd3SURBUUFCCi0tLS0tRU5EIFJTQSBQVUJMSUMgS0VZLS0tLS0K

  # Compression
  # Enable or disable compression at the rocket server level.
  # This is useful for reducing bandwidth usage, especially for large data transfers.
  compression: true
  
# =========================
# Modbus TCP server settings
# =========================
modbus:
  # TCP port for Modbus server
  port: 1502
  # IP address to bind Modbus server
  address: "127.0.0.1"
  # Enable or disable Modbus server
  enabled: false

# =========================
# Photoacoustic acquisition settings
# =========================
photoacoustic:
  # Input source: specify either input_device (e.g. alsa:0) or input_file (wav file)
  #input_device: alsa:0
  input_file: input.wav

  # Excitation frequency in Hz for the laser
  frequency: 2000.0

  # Bandwidth of the band-pass filter (Hz)
  bandwidth: 100.0

  # Analyzer window size (samples)
  # The length is seconds of this window can be calculated as:
  #   frame_size / sampling_rate
  # For example, with a frame_size of 4096 and sampling_rate of 44100:
  #   4096 / 44100 = 0.0929 seconds (approximately 93 ms)
  frame_size: 4096

  # Sampling rate in Hz
  sampling_rate: 44100

  # Number of spectra to average for noise reduction
  averages: 10

  # Simulated photoacoustic source configuration
  # When present, enables simulation mode with comprehensive physics modeling
  # Comment out or set to null to use real hardware sources
  simulated_source:
    # Source type: 'mock' for simple MockSource or 'universal' for full physics simulation
    # - mock: Lightweight simulation with correlation-based signal generation
    # - universal: Complete physics simulation with Helmholtz resonance, gas flow, thermal drift
    source_type: "mock"
    
    # Inter-channel correlation coefficient [-1.0, 1.0] for dual-microphone configuration
    # Used by 'mock' source type for simple correlation-based generation
    correlation: 0.8
    
    # Background noise amplitude [0.0, 1.0] - thermal and electronic noise
    background_noise_amplitude: 0.1
    
    # Helmholtz resonance frequency [Hz] - cell acoustic resonance
    resonance_frequency: 2100.0
    
    # Laser modulation depth [0.0, 1.0] - photoacoustic signal strength
    laser_modulation_depth: 0.8
    
    # Base photoacoustic signal amplitude [0.0, 1.0]
    signal_amplitude: 0.5
    
    # Phase opposition between microphones [degrees] - differential configuration
    phase_opposition_degrees: 180.0
    
    # Temperature drift effect factor [0.0, 0.1] - thermal stability
    temperature_drift_factor: 0.01
    
    # Gas flow noise factor [0.0, 1.0] - turbulent flow effects
    gas_flow_noise_factor: 0.05
    
    # Signal-to-noise ratio factor [0.1, 100.0] - measurement quality
    snr_factor: 10.0
    
    # Laser modulation mode: 'amplitude' (continuous) or 'pulsed' (discrete)
    modulation_mode: "amplitude"
    
    # Pulse width [seconds] - for pulsed modulation mode
    pulse_width_seconds: 0.05
    
    # Pulse frequency [Hz] - for pulsed modulation mode
    pulse_frequency_hz: 20.0

  # Alternative: Universal physics simulation configuration
  # Uncomment and modify the source_type to "universal" to use comprehensive physics modeling
  # simulated_source:
  #   source_type: "universal"
  #   correlation: 0.8
  #   background_noise_amplitude: 0.1
  #   resonance_frequency: 2100.0
  #   laser_modulation_depth: 0.9
  #   signal_amplitude: 0.7
  #   phase_opposition_degrees: 175.0
  #   temperature_drift_factor: 0.02
  #   gas_flow_noise_factor: 0.3
  #   snr_factor: 25.0
  #   modulation_mode: "amplitude"
  #   pulse_width_seconds: 0.005
  #   pulse_frequency_hz: 100.0

  # Record consumer settings
  # If enabled, the stream data will be consumed by the record consumer
  record_consumer: true

# =========================
# Access control and user management
# =========================
access:
  iss: LaserSmartServer # Issuer for JWT tokens
  duration: 86400 # Optional duration in seconds of the issued tokens minimum 3600, maximum 31536000
  users:
    # List of users with hashed passwords and permissions
    # Passwords are hashed (e.g. with openssl passwd -5) and base64-encoded
    - user: administrator
      pass: JDUkcVc2NUtlSTVwb2ZRMC5VTCRmTnl2Vjh4MTJQMnBvcXlGa2htUnNRRWhLRFV3LzIuUVpseDc1UEFxeWdECg== # password: 'password'
      permissions:
        - "read:api"
        - "write:api"
        - "admin:api"
      # Optional user metadata
      email: administrator@example.org
      name: Administrator User
    - user: reader
      pass: JDUkRmp3NUJRLlM1alZkOXVkciRma0E3eG9PYnhiL1Uxam1UeU05VjhzcDVPb1F3VzBSN1gzRW9pMjN0ZVVBCg== # password: '123445678'
      permissions:
        - "read:api"
      email: reader@example.org
  clients:
    # OAuth2/OpenID Connect clients allowed to use the API
    - client_id: LaserSmartClient
      default_scope: "openid profile email read:api write:api"
      allowed_callbacks:
        - "http://localhost:8080/client/"
        - "https://localhost:8080/client/"

  # =========================
  # OAuth2/OpenID Connect client configuration (for web client)
  # =========================
  generix:
    issuer: LaserSmartServer # Issuer for the OAuth2/OpenID Connect server, must match the access.iss value
    provider: generix # Only 'generix' is supported
    api_base_url: https://localhost:8080 # Base URL of the API server
    authority: https://localhost:8080 # Authority URL for OAuth2/OpenID Connect
    client_id: LaserSmartClient # OAuth2/OpenID Connect client ID
    scope: "openid email profile read:api write:api" # Scopes requested by the client
    redirect_uri: https://localhost:8080/client/ # Redirect URI after authentication
    audience: Client # Audience claim in JWT tokens
    token_issuer: https://localhost:8080 # Token issuer base URL
    jwks_endpoint: https://localhost:8080/.well-known/jwks.json # JWKS endpoint for public keys
    domain: localhost # Domain for the client application

# =========================
# Signal processing configuration
# =========================
processing:
  enabled: true
  result_buffer_size: 1000
  default_graph:
    id: default
    nodes:
    - id: input
      node_type: input
      parameters: null
    # Record original audio
    - id: "original_recorder"
      node_type: "record"
      parameters:
        record_file: "./recordings/original.wav"
        max_size: 1024
        auto_delete: false
        total_limit: 5120  # Maximum 5MB total for all recordings
    
    # Apply differential processing
    - id: "differential_detection"
      node_type: "differential"
      parameters: null

    - id: "streaming_post_differential"
      node_type: "streaming"
      parameters: null
    
    - id: bandpass_filter
      node_type: filter
      parameters:
        type: bandpass
        center_frequency: 2000.0  # Center at 2 kHz
        bandwidth: 200.0          # 200 Hz bandwidth (1900-2100 Hz passband)
        order: 2                  # optional order second-order (-12dB/octave)  (must be even)
                                  # for first-order use a combination of lowpass and highpass filters

    # Apply gain adjustment (+3 dB amplification)
    - id: "gain_amplifier"
      node_type: "gain"
      parameters:
        gain_db: 3.0  # +3 dB gain (approximately 1.41x amplification)

    - id: "streaming_bandpass_filter"
      node_type: "streaming"
      parameters: null

    # Record processed audio
    - id: "processed_recorder"
      node_type: "record"
      parameters:
        record_file: "./recordings/processed.wav"
        max_size: 1024
        auto_delete: false
        total_limit: 10240  # Maximum 10MB total for all recordings

    # Graph connections
    connections:
    - from: input
      to: original_recorder
    - from: original_recorder
      to: differential_detection
    - from: differential_detection
      to: streaming_post_differential
    - from: streaming_post_differential
      to: bandpass_filter
    - from: bandpass_filter
      to: streaming_bandpass_filter
    - from: streaming_bandpass_filter
      to: processed_recorder
    - from: streaming_bandpass_filter
      to: gain_amplifier
    - from: gain_amplifier
      to: processed_recorder
      
  performance:
    max_processing_time_us: 10000
    enable_stats: true
    stats_interval_ms: 1000

# =========================
# Thermal regulation configuration
# =========================
thermal_regulation:
  # Enable thermal regulation system
  enabled: false
  
  # I2C bus configurations
  i2c_buses:
    # Physical hardware bus (Raspberry Pi native I2C)
    primary:
      type: "native"  # "native", "cp2112", or "mock"
      device: "/dev/i2c-1"
      # For CP2112:
      # usb_vendor_id: 0x10C4
      # usb_product_id: 0xEA90
      
      # PWM controllers (up to 32)
      pwm_controllers:
        - address: 0x40  # PCA9685 #1
          channels: 16
          frequency_hz: 1000
        - address: 0x41  # PCA9685 #2
          channels: 16
          frequency_hz: 1000
        # ... up to 0x5F for 32 controllers
      
      # ADC converters (up to 4)
      adc_controllers:
        - address: 0x48  # ADS1115 #1
          channels: 4
          resolution: 16
          voltage_ref: 3.3
          gain: "GAIN_TWO"
        - address: 0x49  # ADS1115 #2
          channels: 4
          resolution: 16
          voltage_ref: 3.3
          gain: "GAIN_TWO"
        - address: 0x4A  # ADS1115 #3
          channels: 4
          resolution: 16
          voltage_ref: 3.3
          gain: "GAIN_TWO"
        - address: 0x4B  # ADS1115 #4
          channels: 4
          resolution: 16
          voltage_ref: 3.3
          gain: "GAIN_TWO"
      
      # I2C GPIO controllers (up to 8)
      gpio_controllers:
        - address: 0x20  # CAT9555 #1
          channels: 16
          type: "CAT9555"
          function: "h_bridge_control"
        - address: 0x21  # CAT9555 #2
          channels: 16
          type: "CAT9555"
          function: "h_bridge_control"
        - address: 0x22  # CAT9555 #3
          channels: 16
          type: "CAT9555"
          function: "h_bridge_control"
        # ... up to 0x27 for 8 controllers
    
    # Mock bus for thermal simulation and testing
    # Use this configuration for development and testing thermal regulation
    # before hardware is available. The mock driver simulates a 1016g stainless
    # steel 316 photoacoustic cell (110x30x60mm) with 15x30mm Peltier module
    # and 10W heating resistor with realistic thermal dynamics.
    mock_thermal:
      type: "mock"
      device: "mock_thermal_cell"  # Identifier for mock device
      
      # Mock PWM controllers for thermal simulation
      pwm_controllers:
        - address: 0x40  # Simulated PCA9685 for thermal control
          channels: 16
          frequency_hz: 1000
      
      # Mock ADC controllers for temperature reading simulation
      adc_controllers:
        - address: 0x48  # Simulated ADS1115 for temperature sensors
          channels: 4
          resolution: 16
          voltage_ref: 3.3
          gain: "GAIN_TWO"
      
      # Mock GPIO controllers for H-Bridge simulation
      gpio_controllers:
        - address: 0x20  # Simulated CAT9555 for H-Bridge control
          channels: 16
          type: "CAT9555"
          function: "h_bridge_control"
    
    # Optional secondary bus
    secondary:
      type: "native"  # /dev/i2c-0 or additional CP2112
      device: "/dev/i2c-0"
      # Similar configuration with 32 additional PCA9685 + 4 ADS1115 + 8 CAT9555

  # Individual regulators configuration
  regulators:
    # Physical hardware regulator example
    - id: "sample_temperature"
      name: "Sample Temperature"
      enabled: true
      
      # I2C resource allocation
      i2c_bus: "primary"
      temperature_sensor:
        adc_address: 0x48    # ADS1115 #1
        adc_channel: 0       # Channel 0
        sensor_type: "generic"
      
      actuators:
        # Bidirectional thermal control configuration
        thermal_control:
          pwm_controller:
            address: 0x40  # PCA9685 #1
            channel: 0     # PWM channel for power
          
          direction_controller:
            address: 0x20  # CAT9555 #1
            gpio_pins:
              h_bridge_in1: 0    # GPIO 0 - Direction bit 1
              h_bridge_in2: 1    # GPIO 1 - Direction bit 2
              h_bridge_enable: 2 # GPIO 2 - Enable H-Bridge
              
          # Operating modes
          thermal_modes:
            heating_tec:
              description: "Heating via Peltier module"
              h_bridge_direction: "forward"  # IN1=HIGH, IN2=LOW
              power_range: "0-80%"
              max_power_percent: 80.0
            cooling_tec:
              description: "Cooling via Peltier module"
              h_bridge_direction: "reverse"  # IN1=LOW, IN2=HIGH
              power_range: "0-100%"
              max_power_percent: 100.0
            heating_resistive:
              description: "Heating via resistive element (automatic diode selection)"
              h_bridge_direction: "forward"  # IN1=HIGH, IN2=LOW
              power_range: "0-100%"
              max_power_percent: 100.0
      
      # ADC to temperature conversion using NTC thermistor (10kΩ, β=3977)
      # Configuration for 10kΩ/10kΩ voltage divider with 5V supply
      temperature_conversion:
        # Mathematical formula to convert ADC voltage to temperature in Kelvin
        # NTC formula: 1/T = 1/T0 + ln(R/R0)/β where R = R_pullup * voltage / (V_supply - voltage)
        # Parameters: R_pullup=10kΩ, R0=10kΩ (resistance at 25°C), β=3977, T0=298.15K, V_supply=5V
        # @see https://docs.rs/evalexpr/latest/evalexpr/index.html#builtin-functions for syntax
        # Note: Use `math::ln` for neperian logarithm in evalexpr
        #       Use `math::log` for base-10 logarithm
        formula: "1.0 / (1.0 / 298.15 + math::ln(10000.0 * voltage / (5.0 - voltage) / 10000.0) / 3977.0)"
        adc_resolution: 16  # bits
        voltage_reference: 5.0  # V (supply voltage for voltage divider)
        conversion_type: "ntc_thermistor"  # NTC thermistor with β formula
      
      # PID parameters
      pid_parameters:
        kp: 2.0      # Proportional
        ki: 0.1      # Integral
        kd: 0.05     # Derivative
        setpoint: 298.15  # K (25°C)
        output_min: -100.0
        output_max: 100.0
        integral_max: 50.0  # Anti-windup
      
      # PWM and sampling configuration
      control_parameters:
        sampling_frequency_hz: 10.0
        pwm_frequency_hz: 1000.0
      
      # Safety limits
      safety_limits:
        min_temperature_k: 273.15  # 0°C
        max_temperature_k: 373.15  # 100°C
        max_heating_duty: 80.0     # %
        max_cooling_duty: 80.0     # %
    
    # Mock thermal regulator for testing and development
    # This regulator uses the mock bus to simulate thermal behavior
    # of a 1016g stainless steel 316 photoacoustic cell with realistic
    # thermal dynamics including Peltier cooling/heating and resistive heating
    - id: "mock_cell_temperature"
      name: "Mock Photoacoustic Cell Temperature"
      enabled: true
      
      # Use the mock thermal bus for simulation
      i2c_bus: "mock_thermal"
      temperature_sensor:
        adc_address: 0x48    # Simulated ADS1115
        adc_channel: 0       # Channel 0
        sensor_type: "generic"
      
      actuators:
        # Simulated bidirectional thermal control
        thermal_control:
          pwm_controller:
            address: 0x40  # Simulated PCA9685
            channel: 0     # PWM channel for thermal control
          
          direction_controller:
            address: 0x20  # Simulated CAT9555
            gpio_pins:
              h_bridge_in1: 0    # GPIO 0 - Direction control
              h_bridge_in2: 1    # GPIO 1 - Direction control  
              h_bridge_enable: 2 # GPIO 2 - Enable control
              
          # Thermal modes for mock cell simulation
          thermal_modes:
            heating_tec:
              description: "Mock Peltier heating (1016g SS316 cell)"
              h_bridge_direction: "forward"
              power_range: "0-80%"
              max_power_percent: 80.0
            cooling_tec:
              description: "Mock Peltier cooling (1016g SS316 cell)"
              h_bridge_direction: "reverse"
              power_range: "0-100%"
              max_power_percent: 100.0
            heating_resistive:
              description: "Mock 10W resistive heating"
              h_bridge_direction: "forward"
              power_range: "0-100%"
              max_power_percent: 100.0
      
      # Temperature conversion for NTC thermistor (10kΩ, β=3977)
      # Mock sensor simulating 10kΩ/10kΩ voltage divider with 5V supply
      temperature_conversion:
        # Mathematical formula to convert ADC voltage to temperature in Kelvin
        # NTC formula: 1/T = 1/T0 + ln(R/R0)/β where R = R_pullup * voltage / (V_supply - voltage)
        # Parameters: R_pullup=10kΩ, R0=10kΩ (resistance at 25°C), β=3977, T0=298.15K, V_supply=5V
        formula: "1.0 / (1.0 / 298.15 + math::ln(10000.0 * voltage / (5.0 - voltage) / 10000.0) / 3977.0)"
        adc_resolution: 16  # bits
        voltage_reference: 5.0  # V (supply voltage for voltage divider)
        conversion_type: "ntc_thermistor"  # NTC thermistor with β formula
      
      # PID parameters tuned for mock thermal cell simulation
      pid_parameters:
        kp: 1.0      # Conservative gains for mock testing
        ki: 0.05     # Integral
        kd: 0.02     # Derivative
        setpoint: 303.15  # K (30°C) - test temperature
        output_min: -100.0
        output_max: 100.0
        integral_max: 30.0  # Anti-windup
      
      # Control parameters for mock simulation
      control_parameters:
        sampling_frequency_hz: 5.0   # Slower for testing
        pwm_frequency_hz: 1000.0
      
      # Safety limits for mock testing
      safety_limits:
        min_temperature_k: 273.15  # 0°C
        max_temperature_k: 353.15  # 80°C
        max_heating_duty: 80.0     # %
        max_cooling_duty: 80.0     # %
    
    - id: "detector_temperature"
      name: "Detector Temperature"
      enabled: true
      i2c_bus: "primary"
      temperature_sensor:
        adc_address: 0x48    # ADS1115 #1
        adc_channel: 1       # Channel 1
        sensor_type: "generic"
      actuators:
        thermal_control:
          pwm_controller:
            address: 0x40  # PCA9685 #1
            channel: 1     # PWM channel 1
          direction_controller:
            address: 0x20  # CAT9555 #1
            gpio_pins:
              h_bridge_in1: 3    # GPIO 3
              h_bridge_in2: 4    # GPIO 4
              h_bridge_enable: 5 # GPIO 5
          thermal_modes:
            heating_tec:
              description: "Detector TEC heating"
              h_bridge_direction: "forward"
              power_range: "0-60%"
              max_power_percent: 60.0
            cooling_tec:
              description: "Detector TEC cooling"
              h_bridge_direction: "reverse"
              power_range: "0-100%"
              max_power_percent: 100.0
            heating_resistive:
              description: "Detector resistive heating"
              h_bridge_direction: "forward"
              power_range: "0-80%"
              max_power_percent: 80.0
      # Temperature conversion for NTC thermistor (10kΩ, β=3977)
      # Detector temperature sensor with 10kΩ/10kΩ voltage divider, 5V supply
      temperature_conversion:
        # Mathematical formula to convert ADC voltage to temperature in Kelvin
        # NTC formula: 1/T = 1/T0 + ln(R/R0)/β where R = R_pullup * voltage / (V_supply - voltage)
        # Parameters: R_pullup=10kΩ, R0=10kΩ (resistance at 25°C), β=3977, T0=298.15K, V_supply=5V
        formula: "1.0 / (1.0 / 298.15 + math::ln(10000.0 * voltage / (5.0 - voltage) / 10000.0) / 3977.0)"
        adc_resolution: 16  # bits
        voltage_reference: 5.0  # V (supply voltage for voltage divider)
        conversion_type: "ntc_thermistor"  # NTC thermistor with β formula
      pid_parameters:
        kp: 1.5
        ki: 0.08
        kd: 0.03
        setpoint: 288.15  # K (15°C)
        output_min: -100.0
        output_max: 100.0
        integral_max: 40.0
      control_parameters:
        sampling_frequency_hz: 10.0
        pwm_frequency_hz: 1000.0
      safety_limits:
        min_temperature_k: 263.15  # -10°C
        max_temperature_k: 323.15  # 50°C
        max_heating_duty: 60.0
        max_cooling_duty: 100.0
    
    # Possibility to add up to N regulators according to available resources
    # With 32 PCA9685 × 16 channels = 512 PWM outputs
    # With 4 ADS1115 × 4 channels = 16 analog inputs
    # With 8 CAT9555 × 16 GPIO = 128 GPIO control signals

  # Global thermal regulation system parameters
  global_settings:
    global_sampling_rate_hz: 10.0
    max_concurrent_regulators: 32
    resource_sharing:
      i2c_arbitration_timeout_ms: 100
      max_operation_queue_size: 100
      priority_scheduling: false
    monitoring:
      enable_performance_monitoring: true
      metrics_interval_s: 1.0
      enable_thermal_history: false
      history_buffer_size: 1000